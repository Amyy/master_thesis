\chapter{Conclusion}
\label{cha:conclusion}

In this work, the goal was to analyze quantum-secure hash-based signature systems (HBS) in detail to find opportunities for performance improvements and implementing them. 
To solve this task, the $T_5$-Method of Dodis et al.~\cite{T5_paper} is used to introduce the tree concepts \tftree (see Section~\ref{sec:dodis_t5_merkle_tree}) and \extree (see Section~\ref{sec:ext_t5_tree}). 
It is shown that the Merkle Tree in LMS (and potentially XMSS and other signature schemes) can be substituted with these alternate tree concepts.
Both \tftree and \extree outperform the classical Merkle Tree in key generation and verification time when used in LMS. \tftree needs $25\%$ fewer hash calls for key generation and $14\%$ fewer hash calls for verification. \extree also reduces the amount of hash calls for key generation by $25\%$ and achieves the best result for verification time with $22\%$ fewer hash calls.
The length of the authentication path increases for \tftree and \extree by $29\%$ and $20\%$ respectively. 

Notably, this worse performance for length of the authentication path does have a huge impact as the hash calls for tree generation, as those increase exponentially.
% authpath not increase exponentially! tree generation: yes, verify: linear with tree height

% Hashcalls winternitz to get to leaves are not taken into account, because they are constant.


% ext. t5: authpath length not constant, please take into consideration

% \section{Discussion} % Results / Discussion Results ?

\section{Future Work}

% t5 idea is possible in xmss: XMSS inspected in detail in this work, therefore -> would work with t5 but take into account bitmasks. Therefore, t5 tree concept will have to be adapted.

% It is possible to adopt the \extree concept into SPHINCS simple, because SPHINCS simple does not contain bitmasks. Would work like LMS+T5 concept. 
% (Maybe reference to sphincs+ explanation in related work)

% Concept for T5 tree when not every leaf is "filled" ? -> Possible to use a more variants of one-time key sets, because NIST Parameter set (reference here) fits to binary tree and not leaves = power of 5 tree.
% Idea: do not calculate all "subtrees" of T5 tree.

% Tradeoff: what the signer/verifier generates in one T5 block. For example, signer gives verifier c,d instead of a,b -> signer has to calculate 2 XORs, not verifier or vise versa.