\chapter{Background}
\label{cha:background}
This chapter introduces the scientific background of hash-based signature systems, which serves as the basis for this work.
First, the general concept of digital signature systems and hash functions are elaborated. Afterwards, the most common concepts for hash-based digital signature systems are explained. The presented hash-based schemes are the \textit{Lamport-Diffie one-time signature scheme~(LD-OTS)}, the \textit{Winternitz one-time signature scheme~(W-OTS)}, the \textit{Merkle signature scheme~(MSS)} and the \textit{extended Merkle signature scheme~(XMSS)}.

\section{Digital Signature Schemes}
\label{sec:dig_sign_schemes}
A \textit{digital signature scheme} uses a set of rules and a set of parameters to verify the identity of the originator, the integrity of data and non-repudiation.~\cite{cha:bg_digital_sign_schemes_NIST_standard1992} 
In this section, for explanatory reasons, the term data refers to a message sent from a sender to a receiver across a network (e.g. LAN). 
The sender is the person signing the message, the recipient usually wants to verify the received message. Therefore they are referred to as signer and verifier. Notably, the verifier can also be a third party, not just the recipient.
The \textit{digital signature~$\sigma$} of a message, generated by a digital signature scheme, is a value dependent on some secret known only to the signer (usually the private key~$X$) and on the content of the message being signed.
The corresponding public key~$Y$ can be used to verify the authenticity of the signature without requiring access to the signers private key~$X$.
This ensures that the message actually belongs to the signer - for example to detect a lying signer trying to repudiate their signature, a fraudulent claimant arguing the message is theirs, or a message that has been tampered with.
To ensure the above mentioned properties of digital signatures a digital signature scheme consists of the following parts (see also Figure~\ref{img:digital_sign_system_simple})~\cite{cha:bg_signature_schemes_book_menezes2018_1997} :

\begin{figure}
\centering
\includegraphics[width=\linewidth]{images/Background/Digital_Signaturesystem_Simple.png}
\caption{The general structure of a digital signature system.}
\label{img:digital_sign_system_simple}
\end{figure} 

\begin{enumerate}
\item The \textit{key generation algorithm} creates a private key~$X$ used for signature generation, and a public key $Y$ used for signature verification.
Both keys are mathematically dependent on each other, the way being determined by the specific type of the signature scheme (e.g. the Winternitz signature scheme, see Section~\ref{sec:WOTS_keygen}).

\item The \textit{signing algorithm} creates the digital signature~$\sigma$ of a message depending on the private key $X$ of the signer and the content of the message.
\item The \textit{verification algorithm} is used by the verifier to check the validity of the signature~$\sigma$ and the corresponding message with the public key $Y$.
\end{enumerate}
% Y muss vor signieren der Nachricht veröffentlich werden

% Bild / Schema einfügen

% es wird message digest signiert
% Überleitung zu Hashfunctions

\section{Definition of Hash Functions} 
\label{sec:def_hashfunctions}
The security of the one-time signature methods presented in Section~\ref{sec:one-time_sign_schemes} is based on cryptographically secure hash functions. 
A hash function is a function that can be computed efficiently and maps strings of arbitrary length to strings of fixed length~\cite{cha:bg_hashfunctions_thesis_matusiewicz2007}. 
Therefore, a hash function $h$ is defined as any function $h: \{0,1\}^* \rightarrow \{0,1\}^n$~\cite{cha:bg_hashfunctoins_Stinson2006}. 
A hash function is considered \textit{cryptographically secure} if it has the following properties ~\cite{cha:bg_hashfunctions_BASIC_DEFINITIONS_Springer2004}: 

\begin{enumerate} % vlt: ? -> in x umbenennen in Zeichnungen + x in text auch blau machen damit klar ist, dass es das gesuchte ist
	\item \textbf{Preimage-Resistance / One-wayness}
	 A hash function $h$ is preimage-resistant if given an output value $y$, it is computationally infeasible to find any input which generates this output, i.e. finding any preimage $x$ such that $h(x) = y $, when given any $y$. 

\begin{minipage}[t]{.5\linewidth}
          	\raggedright
            \includegraphics[width=.8\linewidth]{images/Background/preimage_res_horizontal.png}
	      \end{minipage} 

	\item \textbf{Second Preimage-Resistance}
	A hash function $h$ is second preimage-resistant, if given any input value and the corresponding output, it is computationally infeasible to find another distinct
input that produces the same output, i.e. given any $x$ finding a second preimage $x' \neq x$ such that $h(x') = h(x)$. 

\begin{minipage}[t]{.6\linewidth}
          	\raggedright
            \includegraphics[width=.8\linewidth]{images/Background/second_preimage_res_horizontal.png}
	      \end{minipage} 
	
	\item \textbf{Collision Resistance}
	A hash function $h$ is called collision-resistant, if it is computationally infeasible to find a pair of different inputs $x, x'$ that map to the same output value, such that $h(x) = h(x')$.


\begin{minipage}[t]{.6\linewidth}
          	\raggedright
            \includegraphics[width=.8\linewidth]{images/Background/collission_res_horizontal.png}
	      \end{minipage}
	      
\end{enumerate}	      


\section{One-Time Signature Schemes}
\label{sec:one-time_sign_schemes}
This section is based on the work of Buchmann et al.~\cite{book_pqc_bernstein_2004}. 
The two signature schemes Lamport-Diffe and Winternitz are both \textit{one-time signature schemes (OTS)}, meaning the public and private key can be used \textbf{once}, for signing a single message. If they are used for generating more than one signature, the signature can be forged. % vlt rauslöschen einfach
The following types of functions are used for the Lamport-Diffie OTS and the Winternitz One-Time Signature Scheme: 
The cryptographic hash function~$h$ is preimage resistant, second preimage-resistant and collision resistant. It is applied to the original message and generates the message digest.
\begin{equation}
\label{eq:basic_hashfunc}
\textbf{Cryptographic hash function h: } \lbrace 0,1 \rbrace^* \rightarrow \lbrace 0,1 \rbrace^n
\end{equation}
The one-way function~$f$ is a hash function that is at least preimage-resistant and takes a fixed input length because it is applied to the message digest. 

\begin{equation}
\label{eq:one-way-func}
\textbf{One-way function f: } \lbrace 0,1 \rbrace^n \rightarrow \lbrace 0,1 \rbrace ^n
\end{equation}

\subsection{Lamport-Diffie One-Time Signature Scheme (LD-OTS)}
\label{sec:lamport_diffie_ots}
The Lamport–Diffie One-Time Signature Scheme (LD-OTS) was first proposed by Leslie Lamport in 1979~\cite{lamport_signature_scheme_1979}. 

\subsubsection{LD-OTS Key Generation}
The private key~$X$ consists of $2n$ bit strings of length $n$ chosen at random. Because the keys and the signature size depend on $n$, it is also referred to as the security parameter

\begin{equation}
\label{eq:ldots_sign_key}
X = \left(x_{0}\left[0\right], x_{0}\left[1\right], x_{1}\left[0\right], x_{1}\left[1\right], \cdots, x_{n-1}\left[0\right], x_{n-1}\left[1\right] \right)
\end{equation}
The public key $Y$ is created from the private key $X$. For each $x_i[j] \in X, 0 \leq i \leq n-1, j \in \lbrace 0,1 \rbrace$, the one-way function~$f$ (see Equation~\ref{eq:one-way-func}) is applied.

\begin{equation}
y_i[j] \in Y = f(x_i[j]), 0 \leq i \leq n-1, j \in \lbrace 0,1 \rbrace
\end{equation}

\begin{equation}
Y = \left( 
y_{0}\left[0\right], y_{0}\left[1 \right], y_{1}\left[0\right], y_{1}\left[1\right], \cdots, y_{n-1}\left[0\right], y_{n-1}\left[1\right]
\right)
\end{equation}

\subsubsection{LD-OTS Signature Generation} % m has fixed length
Before signing, the public key $Y$ has to be published.
The private key $X$ (see Equation~\ref{eq:ldots_sign_key}) is used to sign the message $M \in \lbrace 0,1 \rbrace^*$. 
The cryptographic hash function $h$ (see Equation~\ref{eq:basic_hashfunc}) is applied to $M$ in order to get the hash digest $m$ of fixed length $n$.

\begin{equation}
\label{eq:hash_message}
m = h(M) = (h_{0}, \cdots, h_{n-1})
\end{equation} % elements of m EITHER m_i OD h_i
For each bit $h_i \in m$, the corresponding $x_i[h_i]$ is chosen from the private key $X$, resulting in the signature $\sigma$ for the message $m$.
\begin{equation}
\sigma = \left(
x_0 \left[ h_0 \right], x_1\left[ h_1 \right], \cdots, x_{n-1}\left[ h_{n-1}\right]
\right) = (\sigma_0, \cdots, \sigma_{n-1})
\end{equation}

\subsubsection{LD-OTS Verification}
After receiving a message $M$ with the corresponding signature $\sigma$, the verifier calculates the message digest $h(M) = m$. 
To verify the given signature $\sigma$, it is necessary to check the following condition.
\begin{equation}
\left(
f(\sigma_0), \cdots, f(\sigma_{n-1})
\right) =
\left(
y_0[h_0], \cdots, y_{n-1}[h_{n-1}]
\right)
\end{equation}
If the condition is true, the signature is valid.

\subsection{Winternitz One-Time Signature Scheme (W-OTS)}
\label{sec:wots_general}
LD-OTS signatures are efficient to calculate but have a large size.
The Winternitz one-time signature scheme (W-OTS) generates signatures with substantially shorter size. W-OTS uses the same hash function (Equation~\ref{eq:basic_hashfunc}) and one-way function (Equation~\ref{eq:one-way-func}) as LD-OTS. To counter adaptive chosen-message attacks, a W-OTS contains a checksum, an example calculation is shown at the end of Section~\ref{sec:checksum_explained}.

\subsubsection{W-OTS Key Generation}
\label{sec:WOTS_keygen}
First, two parameters are selected: The Winternitz-Parameter $w \geq 2$ and the security parameter $n$. As $n$ is the length of the message digest, increasing it leads to higher security because it increases the collision resistance of the hash function. The Winternitz parameter $w$ enables space-time trade-offs (for a detailed explanation see W-OTS Verification in Section~\ref{sec:wots-verification}). 

After selecting the parameters $w$ and $n$, the values $t_1, t_2$ and $t$ are calculated.
The value $t_1$ determines the amount of blocks the message digest $m$ will be separated into (see Equation~\ref{eq:hash_digest_split}):
\begin{equation}
\label{eq:t1}
t_1 = \ceil[\Bigg]{\frac{n}{w}}
\end{equation}
The value $t_2$ determines the amount of blocks the checksum $c$ will be separated into (see also Equation~\ref{eq:checksum_calculation}):
\begin{equation}
\label{eq:t2}
t_2 = \ceil*{\frac{\floor*{\log_2 t_1} + 1 + w}{w} }
\end{equation}
The value $t$ determines the total amount of blocks (see Equation~\ref{eq:block_B_out_of_M_and_C}) as well as the amount of elements in the private and public keys (see Equation~\ref{eq:wots_privkey},~\ref{eq:wots-generation-one-time-public-key}) and the signature (see Equation~\ref{eq:wots_sign_calc}):
\begin{equation}
\label{eq:t}
t = t_1 + t_2
\end{equation}
The private key $X$ consists of $t$ randomly chosen bit strings of length $n$.
\begin{equation}
\label{eq:wots_privkey}
X = (x_0, \cdots, x_{t-1})
\end{equation}
The public key $Y$ is generated by applying the one-way function~$f$ to each element $x_i  \in X$  consecutively $2^w - 1$ times.
\begin{equation}
\label{eq:wots-generation-one-time-public-key}
y_i \in Y =  f^{2^w-1}(x_i), 0 \leq i \leq t-1 
\end{equation}

\begin{equation}
\label{eq:wots_pub_one-time-key}
Y = (y_0, \cdots, y_{t-1})
\end{equation}
Each $y_i \in Y$ is a bit string of length $n$. The public key $Y$ has to be published before the signature can be generated. One value of the public key corresponds to one full \textit{Winternitz chain}. 

\subsubsection{W-OTS Signature Generation}
For signing a message $M \in \lbrace 0,1 \rbrace^*$, the cryptographic hash function~$h$ (see Equation~\ref{eq:basic_hashfunc}) is applied to $M$ (see Equation~\ref{eq:hash_message}). The resulting hash digest $m$ is split into $t_1$ bit strings of length $w$. If $m$ is not divisible by $w$, it is necessary to add leading zeros to $m$ before splitting.

\begin{equation}
\label{eq:hash_digest_split}
m = m_0 \concat m_1 \concat \cdots \concat m_{t_1-1}
\end{equation}
Each bit string $m_i \in m$ is converted to its decimal representation in order to calculate the checksum $c$. A detailed example why the checksum is necessary is shown at the end of Section~\ref{sec:checksum_explained} in W-OTS Checksum Example. 

\begin{equation}
\label{eq:checksum_calculation}
c = \sum_{i = 0}^{t_{1}-1}(2^w-m_i)
\end{equation}
The checksum $c$ is divided into $t_2$ bit strings of length $w$. In order to divide $c$ this way, it may be necessary to add leading zeros to $c$ as a padding.
\begin{equation}
c = c_0 \concat c_1 \concat \cdots \concat c_{t_2 - 1}
\end{equation}
Afterwards, $m$ and $c$ are concatenated to one block~$B$. This leads to $t$ bit strings of length $w$ in total, as $t = t_1 + t_2$.

\begin{align}
\label{eq:block_B_out_of_M_and_C}
B &= m \concat c  \\ 
&= m_0 \concat \cdots \concat m_{t_1 - 1} \concat c_0 \concat \cdots \concat c_{t_2 - 1} \nonumber \\
&= b_0 \concat \cdots \concat b_{t-1} \nonumber
\end{align}
The signature $\sigma$ is calculated by applying the one-way function~$f$ to each part of the private key $X$ (see Equation~\ref{eq:wots_privkey}) several times: The element $b_i \in B$ determines the amount of times the hash function $f$ is applied to the corresponding $x_i \in X$. One element of the signature is also referred to as one \textit{Winternitz chain}.

\begin{equation}
\label{eq:wots_sign_calc}
\sigma = (f^{b_0}(x_0), f^{b_1}(x_1), \cdots, f^{b_{t-1}}(x_{t-1})) = (\sigma_0, \cdots, \sigma_{t-1})
\end{equation}

\subsubsection{W-OTS Verification}
\label{sec:wots-verification}
Given a signature $\sigma$ and message $M$, the hash digest $m$ is generated (see Equation~\ref{eq:hash_message}). Afterwards, the block $B$ is generated out of~$m$ as shown in the previous section (see Equations~\ref{eq:hash_digest_split} to~\ref{eq:block_B_out_of_M_and_C}). To check if the given signature is valid, the one-way function~$f$ is applied $2^w - 1 - b_i$ times to each $\sigma_i \in \sigma$. The result is compared to the corresponding $y_i \in Y$. This can also be interpreted as advancing each Winternitz chain in the signature by applying~$f$ until the  values of the public key are reached.

\begin{equation}
\label{eq:wots_verify}
(f^{(2^w-1)-b_0}(\sigma_0), \cdots, f^{(2^w - 1) - b_{t-1}}(\sigma_{t-1})) \? (y_0, \cdots, y_{t-1})
\end{equation}
If each $f^{2^w-1-b_i}(\sigma_i) = y_i$, the signature is valid because $\sigma_i = f^{b_i}(x_i)$ and therefore

\begin{gather}
f^{2^w-1-b_i}(\sigma_i) = f^{2^w-1}(x_i) = y_i \\
\text{for  }0 \leq i \leq t-1 \nonumber
\end{gather}
As $w$ determines the block size of each block in $B$, $w$ is allowing a space-time trade-off: When increasing $w$, the signature size will decrease linearly (the total amount of blocks in $B$ will decrease) and the effort for key generation, signing and verification will increase exponentially. This is because $w-1$ hash function calls are necessary for public key generation, and $w-1$ hash function calls are necessary for signature generation and verification in total.

\subsubsection{W-OTS Example Calculation}
\label{sec:w-ots_example_calc}
This section contains an example calculation of W-OTS, including key generation, signature generation, and signature verification. This example is not cryptographically secure, it exists for explanatory reasons only.

\begin{enumerate}

\item Choose the parameters $n=3, w=2, \text{message digest } m = 101, {\text{one-way function } f:\{0,1\}^{3} \rightarrow \{0,1\}^{3}, x \rightarrow x+2 \text{ mod } 8}$

\item Calculate $t_1, t_2$ and $t$: \\
$t_1 = \ceil{\frac{n}{w}} = \ceil{\frac{3}{2}} = 2, t_2 = \ceil*{\frac{\floor*{\log_2 t_1} + 1 + w}{w} } = \ceil*{\frac{\floor*{\log_2 2} + 1 + 2}{2} } = 2, {t = t_1 + t_2 = 2+2 = 4}$

\item Choose the private key $X$ with $t=4$ random bit strings of length $n=3$: \\
$X = (x_0, \cdots, x_{t-1}) = (x_0, x_1, x_2, x_3) = 
\begin{psmallmatrix}
1 & 1 & 0 & 1\\
0 & 1 & 1 & 1\\
1 & 1 & 1 & 0
\end{psmallmatrix} \in \{0,1\}^{(3,4)} $

\item Calculate the public key $Y$ from $X$ by applying $f$ to each element in $X$ for $2^w-1 = 3$ times:	
$Y = (y_0, \cdots, y_{t-1}) = (y_0, y_1, y_2, y_3) = 
\begin{psmallmatrix}
0 & 1 & 0 & 1 \\
1 & 0 & 0 & 0 \\
1 & 1 & 1 & 0
\end{psmallmatrix} \in \{0,1\}^{(3,4)} $ 

\item Make $m$ divisible by $w$, by adding a leading zero. Then, split it into blocks of length $w$: $m = 01 \concat 01 = m_0 \concat m_1$. These blocks are used for the checksum calculation: \\ $c = (2^w - m_0) + (2^w - m_1) = (4-1)+(4-1)=6$. To make $c$ divisible by $w$ as well, one leading zero is added to the binary representation of $c$. Then, splitting $c$ in blocks of length $w$ yields $c = 01 \concat 10 = c_0 \concat c_1$.

\item Generate the block $B$ by concatenating $m$ and $c$: \\ $B = m_0 \concat m_1 \concat c_0 \concat c_1 = b_0 \concat b_1 \concat b_2 \concat b_3 = 01 \concat 01 \concat 01 \concat 10 $.

\item The signature $\sigma$ of $m$ is determined by the parameter $B$ and one-way function $f$: \\ 
$\sigma = (f^{b_0}(x_0), f^{b_1}(x_1),f^{b_2}(x_2),f^{b_3}(x_3)) = (f^1(5),f^1(7),f^1(3),f^2(6)) = (\sigma_0, \sigma_1, \sigma_2, \sigma_3) = \\
\begin{psmallmatrix}
1 & 0 & 1 & 0 \\
1 & 0 & 0 & 1 \\
1 & 1 & 1 & 0
\end{psmallmatrix} \in \{0,1\}^{(3,4)} $

\item The verifier knows $Y, w, n$ and therefore $t_1, t_2$ and $t$. After receiving $m$ and $\sigma$ from the signer, the block $B$ is calculated as explained in the previous steps. The validity of the signature $\sigma$ is checked by calculating: \\
$( f^{2^w-1-b_0}(\sigma_0), f^{2^w-1-b_1}(\sigma_1), f^{2^w-1-b_2}(\sigma_2), f^{2^w-1-b_3}(\sigma_3)) = (f^2(7) , f^2(1), f^2(5), f^1(2)) = \\ \begin{psmallmatrix}
0 & 1 & 0 & 1 \\
1 & 0 & 0 & 0 \\
1 & 1 & 1 & 0
\end{psmallmatrix} \in \{0,1\}^{(3,4)} $
\\ Because these values are the same as in the public key $Y$, $\sigma$ is valid. 

\end{enumerate}

\subsubsection{W-OTS Checksum Example}
\label{sec:checksum_explained}
In this section, the necessity of the W-OTS checksum (see also Equation~\ref{eq:checksum_calculation}) is explained with an example. 
The attack prevented by the checksum is an \textit{adaptive chosen-message attack}: It is possible for the attacker to generate new messages with matching signatures which depend on previously obtained signatures and messages~\cite{cha:bg_signature_schemes_book_menezes2018_1997}. 
After obtaining a message and the corresponding signature, the idea behind the attack is to increase the bits of the received message to generate a new message. The hash function is applied respectively to the corresponding digits in the signature, increasing the Winternitz chain. Then, without the checksum, a new valid signature would be generated for the message. For this example, the same parameters for W-OTS are used as in the the section before. % (see section~\ref{sec:w-ots_example_calc}. again_: need correct subsubsection label

\begin{enumerate}
\item We assume the attacker knows the message digest $m = 101$, the corresponding signature $\sigma = (\sigma_0, \sigma_1, \sigma_2, \sigma_3)$ and the parameters $w=2, n=3, Y, f$ of the example in the section before. The attacker can get this information because a digital signature system does not ensure confidentiality of the message or the parameters, the premise is the secrecy of the private key. The goal of the attacker is to forge a signature $\sigma' = (\sigma_0', \sigma_1', \sigma_2', \sigma_3')$ which is a valid for a message $m'$ chosen by the attacker. 
% (e.g. the attacker was also the receiver of the message or intercepted the channel where the message was sent)

\item The attacker calculates $m  = m_0 \concat m_1 = 01 \concat 01$, $c = c_0 \concat c_1 = 01 \concat 10$ and therefore $B =  b_0 \concat b_1 \concat b_2 \concat b_3 = 01 \concat 01 \concat 01 \concat 10$ (see steps 1-6 of section before).

\item The original message digest $m = 101$ is increased by two: $m' = 111$. Make $m'$ divisible by $w = 2$, insert leading zero: $m' = m_0'\concat m_1' = 01 \concat 11$. Calculate checksum $c' = (2^w - m_0') + (2^w - m_1') = (4-1)+(4-3)=4$.
Insert leading zero to $c'$ to make it divisible by $w$: $c' = c_0' \concat c_1' = 01 \concat 00$. Therefore, $B' = b_0' \concat b_1' \concat b_2' \concat b_3' = 01 \concat 11 \concat 01 \concat 00$.

Now, the attacker can forge $\sigma_0', \sigma_1'$ of the signature $\sigma'$:
As $b_0 = b_0' = 01$, $\sigma_0' = \sigma_0$.
Because the difference between $b_1 = 01$ and $b_1' = 11$ is $2$, applying $f$ two more times to $\sigma_1$ leads to $\sigma_1'$: $f^2(\sigma_1) = \sigma_1'$.

Notably, $\sigma_0, \sigma_1$ depend only on the message digest bits $m_0, m_1$, not on the checksum. Therefore, the attacker could forge a signature for $m'$ without the checksum. But because of the checksum bit $c_3 = b_3 = 10, c_3' = b_3' = 00$, $b_3 > b_3'$, it is not possible to calculate $\sigma_3$: The attacker would have to calculate $f^{-2}(\sigma_3)$, that is finding two times a preimage to $\sigma_3$. As long as the hash function $f$ is preimage resistant, which is assumed (see also Equation~\ref{eq:one-way-func}), this is not possible. The attacker can not forge the complete signature $\sigma'$.

\end{enumerate}
For a general proof of security of the checksum, see Section 9.3 in McGrew et al.~\cite{LMS_RFC8554}.
For LD-OTS, the checksum is not necessary because only one hash function call is used to get to the public key $Y$. Therefore, it is not possible to generate another valid signature $\sigma'$ by applying the hash function to the known signature $\sigma$ again.

\section{Merkle Signature Scheme (MSS)} 
\label{sec:mss}
This section is also based on the work of Buchmann et al.~\cite{book_pqc_bernstein_2004}.
The main disadvantage of the one-time signature schemes presented in Section~\ref{sec:one-time_sign_schemes} is the restriction to use each key pair for only one signature. This is inadequate for most practical situations because the key generation as well as the key distribution take a lot of time and effort.
To solve this problem, Merkle~\cite{cha:bg_merkletrees_Merkle_1979} proposed the concept of using a binary hash tree, where each leaf represents a different one-time key pair. The root of the tree is the public key $Y_{MSS}$  which combines the one-time key pairs at the leafs. With a tree depth $d$, $2^d$ one-time key pairs and corresponding signatures can be generated. 
This concept is denoted as \textit{Merkle signature scheme (MSS)} and it works with any cryptographic hash function and any one-time signature scheme. 
The structure of the Winternitz one-time signature scheme fits better into MSS than the Lamport-Diffie one-time signature scheme: If using W-OTS, it is not necessary for the signer to put the public one-time signature key $Y_s$ in the one-time signature $\sigma_s$. The verifier will automatically calculate $Y_s$ from the given one-time signature. Therefore, the chosen one-time signature scheme for MSS in this chapter is W-OTS. The cryptographic hash function~$h$ (see Equation~\ref{eq:basic_hashfunc}) is used. 

The combination of W-OTS with the Merkle Tree will be used in the \textit{Leighton-Micali Signature Scheme (LMS)}, see Section~\ref{sec:lms} (and with an advanced Merkle Tree in XMSS, see Section~\ref{sec:xmss}).

\subsection{MSS Key Generation}
\label{cha:mss_keygen}
The Merkle tree referenced in this section is depicted in Figure~\ref{img:merkle_tree}.
The signer chooses the tree depth~$d$ where $d \geq 2$, and generates $2^d$ one-time key pairs $(X_j, Y_j)$ where $0 \leq j \leq 2^d-1$, with $X_j$ being the private key and $Y_j$ being the corresponding public key. The \textit{leaves} of the Merkle tree are the hash digests $H_{i,j}$ of the public key $Y_j$. 

\begin{gather}
\label{eq:leaf_merkle_tree:hash_digest_publ_key_Y}
H_{i,j} = h(Y_j) \\ 
\text{for } 0 \leq j \leq 2^d - 1 \nonumber
\end{gather}
The \textit{inner nodes} of the Merkle tree are computed as follows: Each parent node $H_{i,j}$ is the hash digest of the concatenation of its direct two children: % $H_{i+1,j}$ and $H_{i+1,j+1}$.

% ! important that 0 <= i < d because leaves don't count
\begin{gather}
\label{eq:inner_nodes_merkle_tree_keygen}
H_{i,j} = h(H_{i-1,2j} \concat H_{i-1,2j+1}) \\
\text{for } 1 \leq i \leq d \nonumber \\ 
\text{for } 0 \leq j < 2^{d - i} \nonumber
\end{gather} 
The \textit{root} of the Merkle tree is the MSS public key~$Y_{MSS}$. The MSS private key~$X_{MSS}$ is the collection of one-time signature keys generated before constructing the Merkle tree.
% Y_mss = H_d,0 because d=height of tree
\begin{align}
\label{eq:mss_priv_key}
X_{MSS} &= (X_0, \cdots, X_j, \cdots, X_{2^d - 1} ) \\
Y_{MSS} &= H_{d,0} \nonumber
\end{align}
The signer publishes the public key $Y_{MSS}$.

\begin{figure}
\centering
% unsichtbare Kante: edge from parent[draw=none]
\begin{tikzpicture} 
[
    level 1/.style = {sibling distance = 8cm},
    level 2/.style = {sibling distance = 4cm},
    level 3/.style = {sibling distance = 2.5cm},
    level 4/.style = {level distance = 1cm}
]
\node {$H_{3,0} = h(H_{2,0} \concat H_{2,1}) = Y_{MSS}$}
	child { node {$H_{2,0} = h(H_{1,0} \concat H_{1,1})$} 
		child { node {$H_{1,0} = h(H_{0,0} \concat H_{0,1})$}
			child{ node {$H_{0,0} = h(Y_0)$}
				child{ node {$Y_0$} edge from parent[<-]
					child{ node {$X_0$} edge from parent[<-,dashed] 
					}
				}	
			}
			child{ node {$H_{0,1} = h(Y_1)$}
				child{ node {$Y_1$} edge from parent[<-]
					child{ node {$X_1$} edge from parent[<-,dashed] 
					}
				}			
			}		
		} 
		child { node {$H_{1,1}$}
			child{ node {$H_{0,2}$}
				child{ node {$Y_2$} edge from parent[<-]
					child{ node {$X_2$} edge from parent[<-,dashed] 
					}					
				}			
			}
			child{ node {$H_{0,3}$}
				child{ node {$Y_3$} edge from parent[<-]
					child{ node {$X_3$} edge from parent[<-,dashed] 
					}
				}			
			}		
		}	
	}
	child { node {$H_{2,1}$} 
		child { node {$H_{1,2}$}
			child {node {$H_{0,4}$}
				child{ node {$Y_4$} edge from parent[<-]
					child{ node {$X_4$} edge from parent[<-,dashed] 
					}
				}			
			}
			child {node {$H_{0,5}$}
				child{ node {$Y_5$} edge from parent[<-]
					child{ node {$X_5$} edge from parent[<-,dashed] }
				}			
			}		
		}
		child { node {$H_{1,3}$}
			child {node {$H_{0,6}$}
				child{ node {$Y_6$} edge from parent[<-]
					child{ node {$X_6$} edge from parent[<-,dashed] 
					}
				}			
			}
			child {node {$H_{0,7}$}
				child{ node {$Y_7$} edge from parent[<-]
					child{ node {$X_7$} edge from parent[<-,dashed] 
					}
				}			
			}
		}	
	}
	;
\end{tikzpicture}
\caption{Merkle tree of depth $d=3$. The composition of the tree is depicted in detail on the left branch, each node consists of the hash digest of its concatenated children (see Equation~\ref{eq:inner_nodes_merkle_tree_keygen}). The leafs are the hash digests of their corresponding one-time public key (see Equation~\ref{eq:leaf_merkle_tree:hash_digest_publ_key_Y}). Because W-OTS is used, the signer generates the public one-time keys by applying the hash function~$h$ for $2^w-1$ times to the corresponding private one-time keys $X_i \in X_{MSS}$ (see Equations~\ref{eq:wots-generation-one-time-public-key} and Equation~\ref{eq:xmss_priv_key}).}
\label{img:merkle_tree}
\end{figure}

\subsubsection{MSS Key Generation: Special Case}
\label{sec:mss_special_keygen}
For simplification, when explaining MSS, each Winternitz one-time key has \textit{one} value (i.e. contains only one Winternitz chain, $t = 1$). There are two methods to transition from Winternitz one-time public key $Y_i$ (with $t > 1$, includes more than one Winternitz chain) to a leaf $H_{0,j}$ in the Merkle Tree, depending on the specific signature scheme. 
These methods are explained in detail for the Leighton-Micali Signature Scheme (hashing $p$ Winternitz chains together, see Section~\ref{sec:lms}) and XMSS (combining an amount of $l$ Winternitz chains with one L-Tree, see Section~\ref{sec:l_tree} and Figure~\ref{img:l_tree}). 

\subsection{MSS Signature Generation}
\label{sec:mss_sig_gen}
The Merkle tree referenced in this section is depicted in Figure~\ref{img:merkle_tree_signature_gen}. 
To sign a message $M$, the signer needs to generate the signature $\sigma_s$.
First, the hash digest $m = h(M)$ of length $n$ (see Equation~\ref{eq:hash_message}) is calculated. Then, by using the chosen one-time signature scheme W-OTS, the one-time signature $\sigma_{s/OTS}$ of $m$ is generated with a one-time key $X_s, s \in \{0, \cdots, 2^d - 1\}, X_s \in X_{MSS}$. % somehow: move "s is part of the signature" here / as first sentence, makes more sense than mentioning that it's part of the signature later

\begin{equation}
\label{eq:merkle_s/OTS_signature}
\sigma_{s/OTS} \leftarrow_{sign} (X_s, m) 
\end{equation}
%\ "The corresponding $Y_s$ is also part of the signature" -> NICHT bei W-OTS, wovon man hier ausgeht. Verifier berechnet Y_s auf dem Weg zur vollen Winternitz-Kette, indem er signatur bekommt und "weiterhasht".
Additional information about the Merkle tree has to be included in $\sigma_s$: The index $s$ and the authentication path for the verification key $Y_s$. The authentication path $A_s$ consists of a sequence of nodes $a_i$ in the Merkle tree:

% a_{d-1}, NOT a_{d} because this would be the root
% a_i vlt rausnehmen aus Sequenz?
\begin{equation}
A_s = (a_0,\cdots, a_i, \cdots, a_{d-1})
\end{equation}
Each node $a_i \in A_s$ is calculated as follows:
% !! floor probably also necessary for first equations
\begin{align}
\label{eq:auth_path_calculation_merkle_tree}
&a_{i} = H_{i, j} \\
&j = 
\left\{\begin{matrix} \nonumber
\floor{s/2^i}-1 \text{ if } \floor{s/2^i} \equiv 1 \mod{2} \\
\floor{s/2^i}+1 \text{ if } \floor{s/2^i} \equiv 0 \mod{2}
\end{matrix}\right.  \nonumber \\
&0 \leq i \leq d-1 \nonumber
\end{align}
In summary, one MSS signature contains the following elements:
% Ys not part of sigma_s?
\begin{equation}
\label{eq:complete_merkle_signature_for_one_Ys}
\sigma_s = (s,\sigma_{s/OTS}, A_s) 
\end{equation}

% ? path h2,0 - h1,0 and h1,1 - h0,0 also with arrows?
% in caption: "path from leaf to the root" not entirely correct, cyan nodes also part of the path?
\begin{figure}
\centering
% unsichtbare Kante: edge from parent[draw=none]
\begin{tikzpicture} 
[
    level 1/.style = {sibling distance = 8cm},
    level 2/.style = {sibling distance = 4cm},
    level 3/.style = {sibling distance = 2.5cm},
    level 4/.style = {level distance = 1cm, sibling distance = 1cm}
    %level 5/.style = {level distance = 1.5cm}
]
\node [darkblue_tud] {$H_{3,0} = p_3 \? Y_{MSS}$ }
	child { node [darkblue_tud] {$H_{2,0} = p_2$ } edge from parent[<-]
		child { node [cyan_tud] {$H_{1,0} = a_1$} edge from parent[-, black]
			child{ node {$H_{0,0} = h(Y_0)$}
				child{ node {$Y_0$} edge from parent[<-]
					child{ node {$X_0$} edge from parent[<-, dashed] 
					}
				}	
			}
			child{ node {$H_{0,1}$}
				child{ node {$Y_1$} edge from parent[<-]
					child{ node {$X_1$} edge from parent[<-, dashed] 
					}
				}			
			}		
		} 
		child { node [darkblue_tud] {$H_{1,1} = p_1$}  edge from parent[<-]
			child{ node [cyan_tud]{$H_{0,2} = a_0$} edge from parent[-, black]
				child{ node {$Y_2$} edge from parent[<-]
					child{ node {$X_2$} edge from parent[<-, dashed] 
					}
				}			
			}
			child{ node [darkblue_tud] {$H_{0,3} = p_0$} edge from parent[<-]
				child{ node {$\textcolor{darkblue_tud}{Y_3}$} edge from parent[<-]
					child{ node {$\textcolor{cyan_tud}{\sigma_{3/OTS}}$} edge from parent[<-, dashed] 
						child{ node {$X_3$} edge from parent[<-, dashed] }
					}
				}			
			}		
		}	
	}
	child { node [cyan_tud] {$H_{2,1} = a_2$} 
		child { node {$H_{1,2}$}
			child {node {$H_{0,4}$}
				child{ node {$Y_4$} edge from parent[<-]
					child{ node {$X_4$} edge from parent[<-, dashed] 
					}
				}			
			}
			child {node {$H_{0,5}$}
				child{ node {$Y_5$} edge from parent[<-]
					child{ node {$X_5$} edge from parent[<-, dashed] 
					}
				}			
			}		
		}
		child { node {$H_{1,3}$}
			child {node {$H_{0,6}$}
				child{ node {$Y_6$} edge from parent[<-]
					child{ node {$X_6$} edge from parent[<-, dashed] 
					}
				}			
			}
			child {node {$H_{0,7}$}
				child{ node {$Y_7$} edge from parent[<-]
					child{ node {$X_7$} edge from parent[<-, dashed] 
					}
				}			
			}
		}	
	}
	;
\end{tikzpicture}
\caption{Example for Merkle signature generation and verification, tree depth $d=3$. The signer generates the Merkle tree and chooses $s=3$, then calculates the signature $\textcolor{cyan_tud}{\sigma_3 = (3, \sigma_{s/OTS},A_3)}$.
The nodes $H_{0,2}, H_{1,0}, H_{2,1}$ are in the \textcolor{cyan_tud}{authentication path $A_3 = (a_0, a_1, a_2)$}. After receiving $\sigma_3$, the verifier uses the one-time signature \textcolor{cyan_tud}{$\sigma_{3/OTS}$} to calculate $\textcolor{darkblue_tud}{Y_3}$ by applying the hash function $h$ a specific amount of times to it (see also Section~\ref{sec:wots-verification}).
Now, with the knowledge of $\textcolor{cyan_tud}{A_3}$ and $\textcolor{cyan_tud}{Y_3}$, the verifier can calculate the \textcolor{darkblue_tud}{path $P_s = (p_0, p_1, p_2, p_3)$}, also indicated by the arrows. If the root $p_3$ calculated by the verifier matches the public key $Y_{MSS}$, the signature $\sigma_3$ is valid.}
\label{img:merkle_tree_signature_gen}
\end{figure}


\subsection{MSS Signature Verification}
\label{sec:mss_sign_verif}
When receiving $\sigma_s$ (see Equation~\ref{eq:complete_merkle_signature_for_one_Ys}), the verifier uses $\sigma_{s/OTS}$ to calculate $Y_s$. This works specifically because W-OTS is used in combination with the Merkle tree: Applying the hash function $h$ for a specific amount of times to $\sigma_s$ (this is determined by the underlying W-OTS, see Section~\ref{sec:wots-verification}) automatically generates $Y_s$.
Because of the index $s$, the verifier knows the leaf-position of the calculated $Y_s$ in the Merkle tree. 
In combination with the authentication path $A_s$, the verifier can construct a path from the leaf $Y_s$ to the root of the Merkle tree: 

\begin{equation}
P_s = (p_0, \cdots, p_d)
\end{equation}
The path $P_s$ is constructed by using the index $s$ and the authentication path $A_s$:

\begin{align}
\label{eq:merkle_verifier_path_calculation}
&p_0 = h(Y_s) \\
&p_{i} = 
\left\{\begin{matrix} \nonumber
h(a_{i-1} \concat p_{i-1}) \text{ if } \floor{s/2^{i-1}} \equiv 1 \mod{2} \\
h(p_{i-1} \concat a_{i-1}) \text{ if } \floor{s/2^{i-1}} \equiv 0 \mod{2}
\end{matrix}\right.  \nonumber \\
&0 \leq i \leq d  \nonumber 
\end{align}
The verification of signature $\sigma_s$ is only successful if the root $p_d$ calculated by the verifier matches the public key $Y_{MSS}$. The one-time key $Y_s$ and therefore the one-time signature $\sigma_s/OTS$ are implicitly validated, as $Y_s$ is calculated on the way to the root of the Merkle tree by the verifier.
This section is also explained in detail with a depiction of the Merkle tree in Figure~\ref{img:merkle_tree_signature_gen}.


\section{Leighton-Micali Signature Scheme (LMS)}
\label{sec:lms}
% insert description of LMS here / "this is basically LMS but LMS also has a seed"
% insert winternitz param / table with param
The \textit{Leighton-Micali Signature Scheme (LMS)}~\cite{LMS_RFC8554} is basically the Merkle Signature Scheme in combination with W-OTS (see Section~\ref{sec:mss}), but the transition from each Winternitz one-time key (which includes several Winternitz chains, see Section~\ref{sec:wots_general}) to the leaf of the Merkle Tree is defined in detail. 
The parameters of LMS are defined in Table~\ref{table:lms_param}.

\begin{table}
\centering
\begin{tabular}{c l} 
 \hline\noalign{\smallskip}
 \multicolumn{2}{c}{\textbf{LMS Parameter}} \\
 symbol & meaning \\ 
 \hline\noalign{\smallskip}
 $n$ & security parameter, length of the hash digest \\
 $w$ & Winternitz parameter, $w \in \{1,2,4,8\}$ \\ % LMS RFC says $w \in \{1,2,4,8}$
 $d$ & height of Merkle Tree \\
 $t$ & amount of elements/Winternitz chains in a single one-time key \\
 $s$ & next unused W-OTS keypair in Merkle Tree \\
 $\ell$ & amount of leaves Merkle Tree / amount of one-time keys, $\ell = 2^d$ \\
 $h$ & cryptographic secure hash function, see Equation~\ref{eq:basic_hashfunc} \\
 $X_{LMS}$ & LMS private key \\
 $Y_{LMS}$ & LMS public key \\
 \hline
\end{tabular}
\caption{Parameter used for LMS, see Section~\ref{sec:lms}~\cite{LMS_RFC8554}.}
\label{table:lms_param}
\end{table}

\subsection{LMS Key Generation}
% calculation hashcalls + wots hashcalls
% reference to mss
The key generation works like for MSS (see Section~\ref{sec:mss}): First, the W-OTS parameters $w, n$ are chosen and $t$ is calculated as in Section~\ref{sec:WOTS_keygen}. In difference to MSS, the amount of Winternitz chains for each one-time key can be greater than one, $t \geq 1$ (see Section~\ref{sec:mss_special_keygen}, MSS Key Generation: Special Case).
Notably, the LMS RFC~\cite{LMS_RFC8554} states slightly different equations for calculating $t$, but this is irrelevant for the scope of this work. 
With the given parameters, $\ell \times$Winternitz one-time keys $X_i, 0 \leq i \leq \ell-1$ are randomly generated. These amount to the private key $X_{LMS}$:

\begin{equation}
X_{LMS} = (X_0, \cdots, X_i, \cdots, X_{\ell-1})
\end{equation} 
To generate the one-time public key $Y_i, 0 \leq i \leq \ell-1$ out of each Winternitz private key, the hash function $f$ is applied $2^{w-1}$-times on each Winterintz chain in each $X_i \in X_{LMS}$, see Equation~\ref{eq:wots-generation-one-time-public-key}.
Each resulting one-time key $Y_i, 0 \leq i \leq \ell-1$ consists of $t$~Winternitz chains, each of length $n$ (see Equation~\ref{eq:wots_pub_one-time-key}). One leaf of the Merkle Tree are generated by concatenating and hashing the Winternitz chains together with function $h$ (see Table~\ref{table:lms_param}). For a public one-time key $Y_i$ that consists of $t$ Winternitz-chains $y_0, \cdots, y_{t-1}$, the Merkle Tree leaf $h(Y_i)$ is generated as follows:

\begin{equation}
h(Y_i) = h(y_0 \concat \cdots \concat y_{t-1})
\end{equation}
For a depiction of the LMS Merkle Tree leaf generation, see also Figure~\ref{img:lms_leaf_gen}.

\begin{figure}
\centering 
\begin{tikzpicture}
[	level 1/.style = {sibling distance=0.5cm},
	level 2/.style = {edge from parent/.style={dashed,draw}, level distance=0.7cm, sibling distance=0.5cm},
	level 3/.style = {edge from parent/.style={solid,draw}, level distance=0.6cm},
	level 4/.style = {edge from parent/.style={solid,draw}},
 	common/.style={solid,circle, draw, inner sep=2.8pt},
 	pubkey/.style={circle, draw,fill=darkblue_tud, inner sep=2.8pt},
 	privkey/.style={solid,draw,circle,fill=cyan_tud, inner sep=2.8pt},
 	merkleleaf/.style={solid,draw,circle,fill=grey_tud, inner sep=2.8pt},
    edge from parent fork down
]
\node(root)[merkleleaf]{} 
			child{node(L1pub1)[pubkey]{} edge from parent[<-] %1st pubkey
				child{node[common]{}
					child{node[common]{}
						child{node(L1priv1)[privkey]{}}
					}			
				}			
			}	
			child{node[pubkey]{} edge from parent[<-] %2. pubkey
				child{node[common]{}
					child{node[common]{}
						child{node[privkey]{}}					
					}			
				}			
			}						
			child{node[pubkey]{} edge from parent[<-] % 3. pubkey
				child{node[common]{}
					child{node[common]{}
						child{node[privkey]{}}					
					}			
				}				
			}
			child{node[pubkey]{} edge from parent[<-]
				child{node[common]{}
					child{node[common]{}
						child{node(L1priv4)[privkey]{}}					
					}			
				}			
			}	
			child{node[pubkey]{} edge from parent[<-]
				child{node[common]{}
					child{node[common]{}
						child{node[privkey]{}}					
					}			
				}			
			}	
			child{node[pubkey]{} edge from parent[<-]
				child{node[common]{}
					child{node[common]{}
						child{node[privkey]{}}					
					}			
				}			
			}		
			child{node[pubkey]{} edge from parent[<-]
				child{node[common]{}
					child{node[common]{}
						child{node[privkey]{}}					
					}			
				}			
			}	
			child{node[pubkey]{} edge from parent[<-]
				child{node[common]{}
					child{node[common]{}
						child{node(L2lastpriv)[privkey]{}}					
					}			
				}			
			};
	
\node[left=2cm of root](leftroot){Merkle leaf}; 
\node[left=4pt of L1priv1](leftL1priv1){};
\node[left=4pt of L1pub1](leftL1pub1){};

% helpline root--Merkle leaf bracket
\draw[color=grey_tud, <-]($(root)-(0.35,0)$)--($(leftroot)+(1.2,0)$);

% bracket w-1
\draw[decorate,decoration={brace,mirror,amplitude=2.5mm}]($(leftL1pub1)+(0,0.15)$)--node[left=7pt]{$w-1$}($(leftL1priv1)-(0,0.15)$);

% bracket l
\draw[decorate,decoration={brace,amplitude=2.5mm, raise=9pt}]($(L2lastpriv)+(0.2,0)$)--node[below=15pt]{$t=8$}($(L1priv1)-(0.22,0)$);

\end{tikzpicture}
\caption{Example depiction for generating the Merkle Tree children out of a single one-time key, with $t$ being the amount of Winternitz chains. Each cyan  node is the start of one chain, each darkblue node the end. The grey node is the leaf of theLMS  Merkle Tree.}
\label{img:lms_leaf_gen}
\end{figure}
Inner nodes and root of the Merkle tree are generated like in MSS (see Equation~\ref{eq:leaf_merkle_tree:hash_digest_publ_key_Y}, \ref{eq:inner_nodes_merkle_tree_keygen} and \ref{eq:mss_priv_key} respectively). The LMS public key $Y_{LMS}$ is the root of the Merkle Tree.

% amount of hashcalls tree generation  binary tree
The amount of hash calls necessary for calculating the Merkle Tree \textit{excluding} the Winternitz chains (i.e. the leaves are already known) is denoted in the following equation:
\begin{equation}
\label{eq:lms_hashcalls_tree_treegen}
\text{\# hashcalls Merkle Tree generation} = \ell - 1
\end{equation}
The amount of hash calls necessary for generating all Merkle Tree leaves is calculated as follows:
\begin{equation}
\text{\# hash calls leaves generation} = \ell \cdot t \cdot (2^w-1)
\end{equation}

In summary, the amount of hash calls for generating the public key $Y_{LMS}$ is:
\begin{equation}
\text{\# hash calls public key generation} = \ell - 1 + \ell \cdot t \cdot (2^w-1)
\end{equation}

\subsection{LMS Signature Generation}
Signature generation works just like in MSS (see Section~\ref{sec:mss_sig_gen}), except the amount of Winternitz chains $t \geq 1$ (see Equation~\ref{eq:wots_sign_calc}).
The length of the authentication path in LMS can be calculated as follow:
\begin{equation}
\label{eq:lms_authpath_el}
\text{\# elements in authpath} = d = \log_2(\ell) = 1.44 \cdot \log(\ell)
\end{equation}

\subsection{LMS Signature Verification}
Signature verification works just like in MSS (see Section~\ref{sec:mss_sig_gen}), except the amount of Winternitz chains $t \geq 1$ (see Equation~\ref{eq:wots_verify}).
The amount of hash calls for signature verification by the verifier are calculated as follows:
\begin{equation}
\label{eq:lms_hashcalls_verify}
\text{\# hash calls verify} = \log_2(\ell) = 1.44 \cdot \log(\ell)  
\end{equation}

\section{Extended Merkle Signature Scheme (XMSS)}
\label{sec:xmss}
The \textit{eXtended Merkle Signature Scheme (XMSS)}~\cite{xmss_RFC8391} is an extension of the Merkle Signature Scheme in combination with W-OTS (see Section~\ref{sec:mss}). One of the main advantages of XMSS is that it does not rely on the collision resistance of the used hash functions, but on weaker properties (preimage-resistance, second preimage-resistance). This is achieved by using additional randomly chosen bitmasks for each invocation of the hash function.
The Winternitz one-time signature scheme that now includes bitmasks is referred to as \textit{W-OTS+} (see Section~\ref{sec:wots+_general}). XMSS is a \textit{stateful} signature scheme, so the private key changes after every signature generation. The notation of parameters used for XMSS in this work is shown in Table~\ref{table:xmms_param}. This section is mostly based on the XMSS RFC~\cite{xmss_RFC8391}.

\subsection{Omitting Collision Resistance}
\label{sec:omit_coll_res}
All of modern cryptography relies on unproven assumptions, only a few cryptographic tasks can be achieved with perfect security (e.g. the one-time pad~\cite{one_time_pad_2013}). There clearly is a risk that at least some of these assumptions may be wrong. Therefore, it is important to only make assumptions that are really necessary.~\cite{minimal_security_assump_phd_2016}
For all signature schemes shown in this work before, collision resistance of the used hash function is a security requirement (see also Section~\ref{sec:def_hashfunctions}). 
With Grover’s algorithm, two ordinary collisions can be found in time $\mathcal{O}(2^{n/3})$, speeding up the classical birthday attack which requires $\mathcal{O}(2^{n/2})$ time (with $n$ being the output length of the specific used hash function)~\cite{colission_complexity_reduction_quantum_2019, birthday_attack_quantum_collision_1998}. % später: Hier auf Grovers-Algo section 
For maintaining the security of the digital signature system, the requirement for collision resistance is omitted, so the only necessary security assumptions are preimage- and second preimage-resistance of the used hash function.
To achieve this, a keyed hash functions (see Equation~\ref{eq:keyed_hashfc_general}) in combination with random bitmasks is used for XMSS. % source xmss draft? or paper, add reference to bitmask equation in this sentence


\subsection{WOTS+}
\label{sec:wots+_general}
This section describes the main difference between WOTS+ and WOTS (see Section~\ref{sec:wots_general}), an overview is given in Table~\ref{table:wots_wots+_diff}. The hash function used for WOTS+ is a \textit{keyed} hash function with \textit{random bitmask} as additional input for each function call. The rest of WOTS+ works just like WOTS.
In general, a keyed hash function $h_{keyed}$ takes a public key $K$ and a message $M$ of arbitrary length and maps it to an output of fixed length $n$. The public key $K$ is an element of the key space~$\mathcal{K}$, $\mathcal{K}=\{0,1\}^n$, $M$ is an element of the message space $\mathcal{M}, M=\{0,1\}$.~\cite{keyed_hashfct_introduct_2006} In XMSS, the key $K$ corresponds to a public seed $sd$. 

% keyed hashfunction
\begin{equation}
\label{eq:keyed_hashfc_general}
h_{keyed}: \mathcal{K} \times \mathcal{M} \rightarrow \{0, 1 \}^n 
\end{equation}
The keyed hash function in combination with the bitmasks is denoted as tweakable hash function, a principle introduced by Bernstein et al.~\cite{tweakable_basispaper_sphincs_2019} and adapted by Campos et al.~\cite{fabio_paper_lms_vs_xmss}. The following definitions are based on the work of Campos et al.~\cite{fabio_paper_lms_vs_xmss}: 
Let $\mathcal{K}$ be the keyspace, $\mathcal{T}$ be the tweakspace (containing the bitmasks), $\mathcal{M}$ the message space (containing the possible inputs), $\mathcal{K}= \mathcal{T}=\mathcal{M}=\{0,1\}^n$.
Then, a tweakable hash function $h_{tweak}$ maps a key $K \in \mathcal{K}$, a bitmask $T \in \mathcal{B}$, and a message $M \in \mathcal{M}$ to a fixed output of length $n$. Notably, the bitmask $T$ \textit{changes} after each invocation of $h_{tweak}$, while the key $K$ (or respectively the public seed $sd$) stays the same.
\begin{equation}
h_{tweak}: \mathcal{K} \times \mathcal{T} \times \mathcal{M} \rightarrow \{0,1\}^n
\end{equation}
In detail, the tweakable hash function $h_{tweak}$ works as follows: Let $h_1, h_2$ be two hash functions. % The input lenght $2n$ is made of B concatenated with K.
\begin{align}
& h_1 : \{0,1\}^{2n} \times \{0,1\}^n \rightarrow \{0,1\}^n \\
& h_2 : \{0,1\}^{2n} \rightarrow \{0,1\}^n 
\end{align}
Then, the tweakable hash function $h_{tweak}$ is constructed. For an explanatory depiction of $h_{tweak}$, see Figure~\ref{img:h_tweak}.

\begin{equation}
\label{eq:tweak_function_h1h2}
h_{tweak}(K,T,M) = h_1(K \concat T , M^{\oplus}), \text{with } M^{\oplus}=M \oplus h_2(K \concat T)
\end{equation}
As defined in Equation~\ref{eq:tweak_function_h1h2}, additional distinct random input for each invocation of $h_{tweak}$ is generated by using the output of $h_2$ as additional input for $h_1$. For further security details of the tweakable hash function, see Bernstein et al.~\cite{tweakable_basispaper_sphincs_2019}. 

% explain h_{tweak}
\begin{figure}
\centering
\begin{tikzpicture}[edge from parent fork down]
\node[](md){output $h_{tweak}$}
	child{node[rectangle, draw](h1){$h_1$} edge from parent[<-]
		child{node[circle,draw] (xor) {\tiny XOR} edge from parent[<-]
			child{node[](m){M}
			}
		}
	};
	
% right bitmask
\node[right=1 of xor, rectangle, draw] (h2) {$h_2$};
\node[right=1 of h2] (h22) {$K \concat T$};
\coordinate[right=1 of h1] (h11);


\draw[<-] ($(xor.east)$) -- (h2);
\draw[<-] ($(h2.east)$) -- (h22);
\draw[<-] (h1) -- (h11) -- (h22);


\draw [decorate, decoration = {brace,raise=20pt, amplitude=5pt}, thick] (m) -- (md) node[pos=0.5, left=30pt]{$h_{tweak}(K,T,M)$};
 

\end{tikzpicture}
\caption{Example depiction of the tweakable hash function $h_{tweak}$ with the input values $K,B,M$ (corresponding to key, bitmask, message). The functions $h1, h2$ are part of $h_{tweak}$ (see Equation~\ref{eq:tweak_function_h1h2}).}
\label{img:h_tweak}
\end{figure}

\begin{table}
\centering
\begin{tabular}{c c l} 
 \hline\noalign{\smallskip}
 \multicolumn{3}{c}{\textbf{WOTS/WOTS+ Parameter}} \\
 \multicolumn{2}{c}{symbol} & meaning \\
 \noalign{\smallskip}
 WOTS & WOTS+ &  \\ 
 \hline\noalign{\smallskip}
 \multicolumn{2}{c}{$n$} & security parameter / output length of used hash function \\
 \multicolumn{2}{c}{$w$} & Winternitz parameter / blocksize  \\ 
 \multicolumn{2}{c}{$b_i \in B$} & one block element (of size $w$) \\ 
 $t$ & $l$ & amount of elements in private/public key, signature \\ 
 $f$ & $h_{tweak}$ & used hash function \\
 - & $B_{wots+}$ & bitmasks necessary for $h_{tweak}$ \\
 - & $sd$ & public seed necessary for $h_{tweak}$ \\ 
 \hline
\end{tabular}
\caption{Symbols and their meaning used for WOTS (see Section~\ref{sec:wots_general}) and WOTS+ (see Section~\ref{sec:wots+_general}) respectively.}
\label{table:wots_wots+_diff}
\end{table}

\subsubsection{WOTS+ Key Generation}
\label{sec:wots+_keygen}
Like in W-OTS (see Section~\ref{sec:WOTS_keygen}), the Winternitz-Parameter~$w$ and the security parameter $n$ are selected. In WOTS+, $w$ is an element of the set $\{4, 16\}$, $n$ is the output length of the hash function $h_{tweak}$.
These parameters are used to calculate $l_1, l_2, l$ (they have the same meaning as $t_1, t_2, t$ in WOTS but the calculation is slightly different).
The value $l_1$ determines the amount of blocks the message digest $m$ will be separated into:
\begin{equation}
l_1 = \ceil*{\frac{n}{\log{2}w}}
\end{equation}
The value $l_2$ determines the amount of blocks the checksum $c$ will be separated into: 
\begin{equation}
l_2 = \floor*{\log_{2} \frac{l_1 (w-1)}{\log_{2}w} } +1
\end{equation}
The value $l$ determines the amount of elements in the private/public key and the signature:
\begin{equation}
l = l_1 + l_2
\end{equation}
The WOTS+ private key consists of $l$ elements, each of length $n$, chosen at random.
\begin{equation}
\label{eq:wots+_privkey}
X = (x_0, \cdots, x_{l-1})
\end{equation}
The WOTS+ public key (see Equation~\ref{eq:wots+_pubkeygen}) is generated by applying the tweakable hash function $h_{tweak}$ (see Equation~\ref{eq:tweak_function_h1h2}) to each element $x_i$ (which can also be seen as the beginning of one WOTS+ chain) in the private key $X$ consecutively for $w-1$ times.In difference to WOTS, the bitmasks $b_{i,j}$ and the public seed $sd$ are additionaly needed for each invocation of the used hash function. Notably, the bitmask $b_{i,j}$ changes for each hash function call, while the seed $sd$ stays the same. The index $i$ of the bitmask denotes the position of the corresponding key element, the index $j$ denotes the height position in the Winternitz chain, $B_{wots+}$ is a set of all bitmasks used for a single WOTS+ key pair.

\begin{equation}
\label{eq:wots+_all_bitmasks}
B_{wots+} = (b_{0,0}, \cdots, b_{i,j}, \cdots, b_{l,w-1})
\end{equation}

\begin{align}
\label{eq:wots+_pubkeygen}
&y_i \in Y = h_{tweak}^{w-1}(sd,b_{i,j}, x_i) \text{ with } j= 0,\cdots,w-1 \\
&Y = (y_0, \cdots, y_{l-1})
\end{align}
For an explanatory depiction of the key generation process, see Figure~\ref{img:wots+_bitmask_hashcall}.


\begin{figure}
\centering
\begin{tikzpicture}
[	level 1/.style = {level distance=1.2cm},
	edge from parent fork down
]
\node[circle,draw,fill=darkblue_tud, inner sep=4]{}
	child{node[rectangle, draw](hashfct2){$h_{tweak}$} edge from parent[<-]
		child{node(cdots){$\cdots$} edge from parent[<-]
			child{ node[rectangle, draw](hashfct1){$h_{tweak}$} edge from parent[<-]
				child{node[circle,draw,fill=cyan_tud, inner sep=4]{}}
			}
		}
	};
	
\node[right=1 of hashfct1] (r1) {$b_{i,1}$};
\node[right=1 of hashfct2] (r2) {$b_{i,w-1}$};
\node[left=1 of hashfct1] (l1) {$sd$};
\node[left=1 of hashfct2] (l2) {$sd$};


\draw[<-]($(hashfct1.east)$) -- (r1);
\draw[<-]($(hashfct2.east)$) -- (r2);
\draw[<-]($(hashfct1.west)$) -- (l1);
\draw[<-]($(hashfct2.west)$) -- (l2);

\end{tikzpicture}
\caption{Example WOTS+ key generation for \textit{one} WOTS+ chain (see Figure~\ref{img:xmss_tree} for the WOTS+ chains in scope of the complete XMSS tree). For each hash function call of $h_{tweak}$, another bitmask $b_{i,j}$ and the same public seed $sd$ are used. The value of $i$ denotes the position of the chain in the one-time key, the value $j$ denotes the height in the chain.
After $w-1$ hash function calls applied consecutively on the private key of this chain (\textcolor{cyan_tud}{cyan node}), the public key of this chain (\textcolor{darkblue_tud}{blue node}) is generated.  }
\label{img:wots+_bitmask_hashcall}
\end{figure}


\subsubsection{WOTS+ Signature Generation \& Verification}
The WOTS+ signature generation and verification works just as for WOTS (see Section~\ref{sec:wots-verification}, WOTS Verification), except that (like for WOTS+ key generation) instead of the function $f$, the tweakable hash function $h_{tweak}$ is used. The seed $sd$ and all bitmasks $B_{wots+}$ (see Equation~\ref{eq:wots+_all_bitmasks}) are known to the verifier. 
Given all necessary parameters, a WOTS+ signature is denoted as follows:
\begin{equation}
\label{eq:wots+_sig_gen}
\sigma_{wots+} = (\sigma_0, \cdots, \sigma_i, \cdots \sigma_{l-1}) \text{ where } \sigma_i = h_{tweak}^{b_i}(sd,b_{i,j},x_i)
\end{equation}

\subsection{XMSS Key Generation}
For a depiction of the XMSS tree referenced in this section, see Figure~\ref{img:xmss_tree}. 

\begin{table}
\begin{center}
\begin{tabular}{c l}
 \hline\noalign{\smallskip}
 \multicolumn{2}{c}{\textbf{XMSS Parameter}} \\
 symbol & meaning \\
 \hline\noalign{\smallskip} 
 $l$ & amount of leaves of the L-Tree / elements in one WOTS+ key  \\ 
 $\ceil{log(l)}$ & height of one L-Tree in the XMSS tree \\
 $d$ & height of Merkle tree in the XMSS tree  \\ 
 $D$ & height of the complete XMSS tree, $D = \ceil{log(l)} + d$ \\
 $h_{tweak}$ & tweakable hash function \\
 $sd$ & public seed, key for hash function $h_{tweak}$ \\
 $b_{i,j} \in B_{XMSS}$ & bitmask in XMSS tree on position $i,j$ \\
 $s_{next}$ & index of next unused WOTS+ keypair \\
 \hline 
\end{tabular}
\caption{Symbols and parameters used for describing XMSS.}
\label{table:xmms_param}
\end{center}
\end{table}
First, the signer chooses the WOTS+ parameters $n, w$ (see Section~\ref{sec:wots+_keygen}/WOTS+ Key Generation).
Then, $2^d$ WOTS+ one-time private keys (see Equation~\ref{eq:wots+_privkey}) are generated, $d$ denotes the height of the Merkle tree inside the XMSS tree. % ref to merkle tree inside xmss tree 
Each leaf of the MSS tree in the XMSS tree is one WOTS+ one-time public key. 
The leaf index $s_{next}$ denotes the next unused WOTS+ one-time private key (to ensure it is only used once), a seed $sd$ (it corresponds to the key $K$ when using $h_{tweak}$, see Equation~\ref{eq:tweak_function_h1h2}).
\begin{align}
\label{eq:xmss_priv_key}
X_{XMSS} = ((X_0, \cdots, X_{2^d-1}), s_{next}, sd)
\end{align}
The public key $Y_{XMSS}$ consists of the root of the XMSS tree $Y_{root}$ and the public seed $sd$. The bitmasks $B_{xmss}$ as well as $B_{wots+}$ necessary for building the XMSS tree are already known to the verifier.
\begin{equation}
\label{eq:xmss_pubkey}
Y_{XMSS} = (Y_{root}, sd)
\end{equation}
The leaf index $s_{next}$ is initialized to zero when the XMSS private key is created.

As $h_{tweak}$ is used, the bitmasks $B_{XMSS}$ are necessary to generate the whole XMSS tree. One $b_{i,j} \in B_{XMSS}$ corresponds to $T$ when using $h_{tweak}$, see Equation~\ref{eq:tweak_function_h1h2}), $D$ denotes the height of the complete XMSS tree:
\begin{align}
B_{XMSS} &= (b_{0,0}, \cdots, b_{i,j}, \cdots, b_{D,2^{D-1}})  \\
0 &\leq i \leq D \nonumber \\ 
0 &\leq j \leq 2^{D-1} \nonumber
\end{align}

\subsubsection{L-Tree}
\label{sec:l_tree}
The L-Tree is a concept to combine each WOTS+ one-time key into a leaf of the Merkle tree, see Figure~\ref{img:l_tree}: It compresses the WOTS+ public key into one value. As $h_{tweak}$ is used, $sd$ and the corresponding bitmasks are also needed for generating the L-Tree.

\begin{figure}
\centering 
\begin{tikzpicture}
[	level 1/.style = {level distance=1cm, sibling distance=2cm},
	level 2/.style = {edge from parent/.style={solid,draw}, sibling distance=1cm, },
	level 3/.style = {sibling distance=0.5cm},
	level 4/.style = {edge from parent/.style={dashed,draw}, level distance=0.65cm},
	level 5/.style = {edge from parent/.style={solid,draw}},
 	common/.style={solid,circle, draw, inner sep=2.8pt},
 	pubkey/.style={circle, draw,fill=darkblue_tud, inner sep=2.8pt},
 	privkey/.style={solid,draw,circle,fill=cyan_tud, inner sep=2.8pt},
 	merkleleaf/.style={solid,draw,circle,fill=grey_tud, inner sep=2.8pt},
    edge from parent fork down
]
\node(root)[merkleleaf]{} 
	child{node[common]{} edge from parent[<-] %1.layer 1.node 
		child{node(L1C1)[common]{} %2.layer 1.node
			child{node(L1pub1)[pubkey]{} 
				child{node[common]{}
					child{node[common]{}
						child{node(L1priv1)[privkey]{}}
					}			
				}			
			}	
			child{node[pubkey]{} 
				child{node[common]{}
					child{node[common]{}
						child{node[privkey]{}}					
					}			
				}			
			}						
		}
		child{node[common]{}
			child{node[pubkey]{} 
				child{node[common]{}
					child{node[common]{}
						child{node[privkey]{}}					
					}			
				}				
			}
			child{node[pubkey]{} 
				child{node[common]{}
					child{node[common]{}
						child{node(L1priv4)[privkey]{}}					
					}			
				}			
			}	
		}
	}
	child{node[common]{} edge from parent[<-]  %1.layer 2.node
		child{node[common]{} 
			child{node[pubkey]{} 
				child{node[common]{}
					child{node[common]{}
						child{node[privkey]{}}					
					}			
				}			
			}	
			child{node[pubkey]{} 
				child{node[common]{}
					child{node[common]{}
						child{node[privkey]{}}					
					}			
				}			
			}		
		}
		child{node(2L2C)[common]{}
			child{node[pubkey]{} 
				child{node[common]{}
					child{node[common]{}
						child{node[privkey]{}}					
					}			
				}			
			}	
			child{node[pubkey]{} 
				child{node[common]{}
					child{node[common]{}
						child{node(L2lastpriv)[privkey]{}}					
					}			
				}			
			}
		}	
	};
	

\node[left=2cm of root](leftroot){}; 
\node[left=of L1C1](leftL1C1){}; 
\node[left=4pt of L1priv1](leftL1priv1){};
\node[left=4pt of L1pub1](leftL1pub1){};

% bracket log(l)
\draw[decorate,decoration={brace,mirror,amplitude=2.5mm,aspect=0.3}](leftroot.5)--node[above left=6pt]{$\ceil{\log(l)}=3$}(leftL1C1);

% helpline under log bracket
\draw[color=grey_tud]($(L1C1)-(0.35,0)$)--(leftL1C1);
% helpline root--log(l) bracket
\draw[color=grey_tud]($(root)-(0.35,0)$)--($(leftroot)+(0.35,0)$);

% bracket w-1
\draw[decorate,decoration={brace,mirror,amplitude=2.5mm}]($(leftL1pub1)+(0,0.15)$)--node[left=7pt]{$w-1$}($(leftL1priv1)-(0,0.15)$);

% bracket l
\draw[decorate,decoration={brace,amplitude=2.5mm, raise=9pt}]($(L2lastpriv)+(0.2,0)$)--node[below=15pt]{$l=8$}($(L1priv1)-(0.22,0)$);

% bracket L-Tree
\draw[decorate,decoration={brace,amplitude=2.5mm, raise=20pt, aspect=0.4}](root)--node[above right=27pt]{L-Tree}($(2L2C)-(0,0.3)$);

\end{tikzpicture}
\caption{Example depiction of one L-Tree (see Section~\ref{sec:l_tree}/L-Tree), the WOTS+ one-time key has $l=8$ elements. Each \textcolor{cyan_tud}{cyan node} is the beginning of one WOTS+ chain, each \textcolor{darkblue_tud}{blue node} denotes the end of one WOTS+ chain. The L-Tree (with height $\ceil{\log(l)}=3$) combines each chain to one Merkle tree child (\textcolor{grey_tud}{grey node} at the root), see also Figure~\ref{img:xmss_tree}.
} 
\label{img:l_tree}
\end{figure}

\subsection{XMSS Signature Generation}
The signature generation works like for MSS in combination with WOTS (see Section~\ref{sec:mss_sig_gen}), but the used hash function is $h_{tweak}$ with its corresponding inputs $sd, B_{XMSS}$ (see Equation~\ref{eq:tweak_function_h1h2}).

Moreover, the L-Tree structure (see Section~\ref{sec:l_tree}/L-Tree) is used to generate the Merkle leaves out of the WOTS+ key pairs.
Given the message $M$, the message digest is computed with $h_{tweak}$. 
A XMSS signature $\sigma_{xmss}$ for $m$ contains the WOTS+ signature $\sigma_{wots+}$, the authentication path $A_s$, and the index $s$ (indicates the WOTS+ key pair used for this signature). For a more specific explanation of these parameters, see also Section~\ref{sec:mss_sig_gen}.

\begin{equation}
\label{eq:xmss_sign}
\sigma_{XMSS} = (s, \sigma_{wots+}, A_s) 
\end{equation}
After signing the message digest $m$, the index $s_{next}$ of the next unused one-time key pair in the private key $X_{XMSS}$ is updated.

\subsection{XMSS Signature Verification}
The signature verification also works similar to MSS in combination with WOTS (see Section~\ref{sec:mss_sign_verif}). For an overview of the parameters used for XMSS, see Table~\ref{table:xmms_param}.
 Like in the steps before, the hash function $h_{tweak}$ is used.
Given the public key $Y_{XMSS}$ and signature $\sigma_{XMSS}$, the verifier takes $\sigma_{wots+} \in \sigma_{XMSS}$ to calculate the leaves of the L-Tree (or in other words, the public one-time WOTS+ key). Then, the root of the L-Tree or respectively the leaf of the Merkle tree is created (see also Figure~\ref{img:l_tree} and Figure~\ref{img:xmss_tree}). With $A_s \in \sigma_{XMSS}$, the verifier calculates a path from the Merkle tree leaf to the root of the XMSS tree. Now, the root calculated by the verifier is compared to $Y_{root} \in Y_{XMSS}$. The verification succeeds only if the calculated root value matches the value $Y_{root}$.
For a more specific explanation of the signing process and the used parameters, see also Section~\ref{sec:mss_sign_verif}.

% xmss example tree
\begin{figure}
\centering 
\begin{tikzpicture}
[	
	level 1/.style = {sibling distance = 3.5cm, level distance=1.1cm},
	level 2/.style = {sibling distance = 6cm},
	level 3/.style = {sibling distance = 3cm},
    level 4/.style = {sibling distance = 0.7cm},
    level 5/.style = {sibling distance = 0.6cm},
    level 6/.style = {sibling distance = 0.8cm},
    level 7/.style = {sibling distance = 0.4cm},
    level 8/.style = {edge from parent/.style={dashed,draw},level distance=0.8cm},
    level 9/.style = {edge from parent/.style={solid,draw},level distance=0.55cm},
 	common/.style={solid,circle, draw, inner sep=2.8pt},
 	pubkey/.style={circle, draw,fill=darkblue_tud, inner sep=2.8pt},
 	privkey/.style={solid,draw,circle,fill=cyan_tud, inner sep=2.8pt},
 	merkleleaf/.style={solid,draw,circle,fill=grey_tud, inner sep=2.8pt},
	interrupt/.style={<-,
		postaction={decorate, decoration={markings,
                    						mark= at position 0.5 with {
                    				\fill[white](-0.1,-0.3) rectangle(0.35,0.35); 
                            		\node[] at (0.2,-0.04){$\cdots$};
                            }
			}
		}
	},
    edge from parent fork down
]
\node(root)[](root){$Y_{root}$}
	child{node[common](L1N1){} edge from parent[draw=none] %1.layer 1.node
		child{node[common]{} edge from parent[<-]
			child{node(L3N1)[merkleleaf]{} % 3.layer 1.node
				child{node[common](L4N1LTree1){}  % 1st L-Tree layer 1.node 
					child{node[common](L5N1LTree1){} edge from parent[draw=none]
						child{node(child1LTree1)[common]{} %1. child 1. L-Tree
							child{node(pub1LTree1)[pubkey]{} % 1.pubkey 1.L-Tree
								child{node[common]{}
									child{node[common]{}
										child{node(priv1LTree1)[privkey]{}} %1.L-Tree 1.priv key		
										}				
								}
							}
							child{node[pubkey]{}
								child{node[common]{}
									child{node[common]{}
										child{node[privkey]{}}			
										}				
								}							
							}
						}
						child{node[common]{} %2. child 1. L-Tree	
							child{node[pubkey]{}
								child{node[common]{}
									child{node[common]{}
										child{node[privkey]{}}			
										}				
								}							
							}
							child{node[pubkey]{}
								child{node[common]{}
									child{node[common]{}
										child{node[privkey]{}}			
										}				
								}							
							}			
						} 			
					}
					child{node[]{} edge from parent[draw=none]} 
				}
				child{node[common](L4N2LTree1){} %4.layer, 2.node
					child{node[]{} edge from parent[draw=none]} % invisible
					child{node[]{} edge from parent[draw=none] %5.layer,1.L-Tree (invisible)
						child{node[common](L5N3LTree1){} edge from parent[draw=none] % 1.L-Tree last child
							child{node[]{$\cdots$} edge from parent[draw=none]}
								child{node[pubkey]{}
									child{node[common]{}
										child{node[common]{}
											child{node(priv5LTree1)[privkey]{}}	 %last privkey, 1.L-Tree
										}				
									}								
								}			
							}
						} 
				}  
			} 
			child{node[merkleleaf]{} %3. layer 2.node
				child{node[common](L4N3LTree2){}  % 2.L-Tree layer 1.node 
					child{node[common](L5N3LTree2){} edge from parent[draw=none]
						child{node[common]{} %1. child 2.L-Tree
							child{node[pubkey]{}
									child{node[common]{}
										child{node[common]{}
											child{node[privkey]{}}			
										}				
									}							
							}
							child{node[pubkey]{}
									child{node[common]{}
										child{node[common]{}
											child{node[privkey]{}}			
										}				
									}							
							}
						}
						child{node[common]{} %2. child 2.L-Tree	
							child{node[pubkey]{}
									child{node[common]{}
										child{node[common]{}
											child{node[privkey]{}}			
										}				
									}							
							}
							child{node[pubkey]{}
									child{node[common]{}
										child{node[common]{}
											child{node[privkey]{}}			
										}				
									}							
							}			
						} 			
					}
					child{node[]{} edge from parent[draw=none]} 
				}
				child{node[common](L4N4LTree2){}
					child{node[]{} edge from parent[draw=none]} % invisible
					child{node[]{} edge from parent[draw=none] %5.layer,2.L-Tree (invisible)
						child{node[common](L5N6LTree2){} edge from parent[draw=none] % 1.L-Tree last child
							child{node[]{$\cdots$} edge from parent[draw=none]}
								child{node[pubkey]{}
									child{node[common]{}
										child{node[common]{}
											child{node[privkey]{}}			
										}				
									}								
								}			
							}
						} 
				}  	
			} 	
		}
		child{node[common]{} edge from parent[<-]
			child{node[merkleleaf]{}  %3. layer 3.node
				child{node[common](L4N5LTree3){}  % 3.L-Tree layer 1.node 
					child{node[common](L5N5LTree3){} edge from parent[draw=none]
						child{node[common]{} %1. child 3.L-Tree
							child{node[pubkey]{}
									child{node[common]{}
										child{node[common]{}
											child{node[privkey]{}}			
										}				
									}							
							}
							child{node[pubkey]{}
									child{node[common]{}
										child{node[common]{}
											child{node[privkey]{}}			
										}				
									}							
							}
						}
						child{node[common]{} %2. child 3.L-Tree	
							child{node[pubkey]{}
									child{node[common]{}
										child{node[common]{}
											child{node[privkey]{}}			
										}				
									}							
							}
							child{node[pubkey]{}
									child{node[common]{}
										child{node[common]{}
											child{node[privkey]{}}			
										}				
									}							
							}			
						} 			
					}
					child{node[]{} edge from parent[draw=none]} 
				}
				child{node[common](L4N6LTree3){}
					child{node[]{} edge from parent[draw=none]} % invisible
					child{node[]{} edge from parent[draw=none] %5.layer,3.L-Tree (invisible)
						child{node[common](L5N6LTree3){} edge from parent[draw=none] % 3.L-Tree last child
							child{node[]{$\cdots$} edge from parent[draw=none]}
								child{node[pubkey]{}
									child{node[common]{}
										child{node[common]{}
											child{node[privkey]{}}			
										}				
									}								
								}			
							}
						} 
				}  
			}
			child{node[merkleleaf]{}  %3. layer 4.node
				child{node[common](L4N7LTree4){}  % 4.L-Tree layer 1.node 
					child{node[common](L5N7LTree4){} edge from parent[draw=none]
						child{node[common]{} %1.child 4.L-Tree
							child{node[pubkey]{}
									child{node[common]{}
										child{node[common]{}
											child{node[privkey]{}}			
										}				
									}							
							}
							child{node[pubkey]{}
									child{node[common]{}
										child{node[common]{}
											child{node[privkey]{}}			
										}				
									}							
							}
						}
						child{node[common]{} %2.child 4.L-Tree	
							child{node[pubkey]{}
									child{node[common]{}
										child{node[common]{}
											child{node[privkey]{}}			
										}				
									}							
							}
							child{node[pubkey]{}
									child{node[common]{}
										child{node[common]{}
											child{node[privkey]{}}			
										}				
									}							
							}			
						} 			
					}
					child{node[]{} edge from parent[draw=none]} 
				}
				child{node[common](L4N8LTree4){}
					child{node[]{} edge from parent[draw=none]} % invisible
					child{node[]{} edge from parent[draw=none] %5.layer,4.L-Tree (invisible)
						child{node[common](L5N8LTree4){} edge from parent[draw=none] % 4.L-Tree last child
							child{node[]{$\cdots$} edge from parent[draw=none]}
								child{node[pubkey]{}
									child{node[common]{}
										child{node[common]{}
											child{node[privkey]{}}			
										}				
									}								
								}			
							}
						} 
				}			
			}
		}
	}
	child{node[](L1N2){} edge from parent[draw=none] %1.layer 2.node (invisible)
		child{node[]{} edge from parent[draw=none]}
		child{node[common] (L2N3){} edge from parent[draw=none] %2.layer 3.node
			child{node[]{} edge from parent[draw=none]}
			child{node[merkleleaf]{} edge from parent[<-] %3.layer, 5.node
				child{node[common](L4N9LTree5){}  % last.L-Tree layer 1.node 
					child{node[common](L5N9LTree5){} edge from parent[draw=none]
						child{node[common]{} %1.child last L-Tree
							child{node[pubkey]{}
									child{node[common]{}
										child{node[common]{}
											child{node[privkey]{}}			
										}				
									}							
							}
							child{node[pubkey]{}
									child{node[common]{}
										child{node[common]{}
											child{node[privkey]{}}			
										}				
									}							
							}
						}
						child{node[common]{} %2.child last L-Tree	
							child{node[pubkey]{}
									child{node[common]{}
										child{node[common]{}
											child{node[privkey]{}}			
										}				
									}							
							}
							child{node[pubkey]{}
									child{node[common]{}
										child{node[common]{}
											child{node[privkey]{}}			
										}				
									}							
							}			
						} 			
					}
					child{node[]{} edge from parent[draw=none]} 
				}
				child{node[common](L4N10LTree5){}
					child{node[]{} edge from parent[draw=none]} % invisible
					child{node[]{} edge from parent[draw=none] %5.layer,last L-Tree (invisible)
						child{node[common](L5N10LTree5){} edge from parent[draw=none] % last L-Tree, last child
							child{node[]{$\cdots$} edge from parent[draw=none]}
								child{node[pubkey]{}
									child{node[common]{}
										child{node[common]{}
											child{node[privkey]{}}			
										}				
									}								
								}			
							}
						} 
				}			
			}			
		} 
	};

% lines with dots ... in between
\draw[interrupt](root) -- (L2N3); % L2=Layer2,L3=Node3 etc.
\draw[interrupt](root) -- (L1N1);

\draw[interrupt](L4N1LTree1) -- (L5N1LTree1);
\draw[interrupt](L4N2LTree1) -- (L5N3LTree1);

\draw[interrupt](L4N3LTree2) -- (L5N3LTree2);
\draw[interrupt](L4N4LTree2) -- (L5N6LTree2);

\draw[interrupt](L4N5LTree3) -- (L5N5LTree3);
\draw[interrupt](L4N6LTree3) -- (L5N6LTree3);

\draw[interrupt](L4N7LTree4) -- (L5N7LTree4);
\draw[interrupt](L4N8LTree4) -- (L5N8LTree4);

\draw[interrupt](L4N9LTree5) -- (L5N9LTree5);
\draw[interrupt](L4N10LTree5) -- (L5N10LTree5);

% Merkle tree bracket
\node[left=1.5cm of L3N1](leftL3N1){}; % helpnode grey line
\draw[color=grey_tud]($(L3N1)-(0.4,0)$)--($(leftL3N1)+(0,0)$); % helpline 1.Merkle child

\draw[decorate,decoration={brace,mirror,amplitude=3mm, aspect=0.53, raise=6pt}]($(root)+(-0.8,0.25)$) -- node[above left=18pt]{Merkle tree}($(leftL3N1)+(0,0)$);

% 1. l bracket
\draw[decorate,decoration={brace,mirror,amplitude=2mm, aspect=0.5}]($(priv1LTree1)+(-0.15,-0.4)$) -- node[below=10pt]{$l$ chains}($(priv5LTree1)+(0.15,-0.4)$);


% w-1 bracket
\draw[decorate,decoration={brace,amplitude=2mm, aspect=0.5}]($(priv1LTree1)+(-0.4,-0.1)$) -- node[left=8pt]{$w-1$}($(pub1LTree1)+(-0.4,0.1)$);

% "L-Tree" bracket
\draw[decorate,decoration={brace ,amplitude=2mm, aspect=0.45, raise=2pt}]($(child1LTree1)+(-0.5,0)$) -- node[left=12pt]{L-Tree}($(L3N1)+(-0.5,-0.17)$);

\end{tikzpicture}
\caption{Example depiction of a XMSS tree. The root is the public $XMSS$ key $Y_{XMSS}$, the first $d$ layers are the Merkle tree. The \textcolor{darkblue_tud}{blue nodes} are the public keys, the \textcolor{cyan_tud}{cyan nodes} are the private keys of the WOTS+ chains. One leaf of the Merkle tree (\textcolor{grey_tud}{grey nodes}) or respectively one L-Tree corresponds to a complete one-time WOTS+ public key.
The depiction is based on Figure~1 in Campos et al.~\cite{fabio_paper_lms_vs_xmss}.} % maybe for consistency: exchange darkblue/grey, make merkle leaves dark blue
\label{img:xmss_tree}
\end{figure}

% source https://eprint.iacr.org/2011/484.pdf:
%\begin{equation}
%\label{eq:xmss_bitmasks}
%H_{i,j} =  h(H_{i-1,2j} \oplus b_{i,left} \concat H_{i-1,2j+1} \oplus b_{i,right})
%\end{equation}

% explain bitmasks on xmss with little tree image:
%\begin{figure}
%\centering
%\begin{tikzpicture}[edge from parent fork down]
%\node(root){$H_{i,j}$}
%	child{node[rectangle, draw](root2){Hashfunction $h$} edge from parent [<-]
%		child {node(a)[circle, draw] {\tiny XOR} edge from parent [<-]
%			child {node(c) {$H_{i-1,2j}$}}
%		}
%		child{node(b)[circle, draw] {\tiny XOR} edge from parent [<-]
%			child{node(d) {$H_{i-1,2j+1}$}}	
%		}
%	};
%	
%% left bitmask	
%\node[left=1 of a] (la) {$b_{i,left}$}; 
%
%% right bitmask
%\node[right=1 of b] (rb) {$b_{i,right}$};
%
%% arrow from left bitmask to left XOR
%\draw[<-] %line from la (left bitmask) -> left XOR
%    ($(a.west)$) -- (la);	
%
%% arrow from right bitmask to right XOR
%\draw[<-] %line from rb (right bitmask) -> right XOR
%    ($(b.east)$) -- (rb);	
%
%\end{tikzpicture}
%\caption{An example parent node $H_{i,j}$ with the corresponding children $H_{i-1,2j},H_{i-1,2j+1}$ of a XMSS tree. The node $H_{i,j}$ is calculated by adding two bitmasks $b_{i,left}, b_{i,right}$ to its children. The result is concatenated and used as input for the hashfunction~$h$ (see Equation~\ref{eq:xmss_bitmasks}).} % Each non-leaf tree node is computed by first concatenating the values of its child nodes, computing the XOR with a bitmask, and applying the keyed hash function H to the result. 
%\label{img:example_xmss_minitree}
%\end{figure}

% -------- EXAMPLE GRAPH -------------------
%\begin{figure}
%\centering
%\begin{tikzpicture}[
%    level/.style={sibling distance=40mm/#1}
%    ]
%
%\node (z){z} 
%  child {node (a) {node1}
%    child {node  (b) {node3}
%      child {node (b1) {$\vdots$} 
%       child {node (b11) {b11}}
%      }
%      child {node (b2) {$\vdots$} 
%       child {node (b12) {leaf1}}
%      }
%    }
%    child {node (g) {node4}
%      child {node (g1) {$\vdots$}
%       child {node (g11) {...}}
%      }
%      child {node (g2) {$\vdots$} 
%       child {node (g12) {g12}}
%      }
%    }
%  }
%    child {node (d) {node2}
%      child {node  (e) {node5}
%        child {node (e1) {$\vdots$} 
%         child {node (e11) {e11}}
%        }
%        child {node (e2) {$\vdots$} 
%         child {node (e12) {...}}
%        }
%      }
%      child {node (f) {node6}
%        child {node (f1) {$\vdots$} 
%         child {node (f11) {...}}
%        }
%        child {node (f2) {$\vdots$} 
%         child {node (f12) {f12}
%         }
%         }
%  }
%};
%
%% cn's on left side of tree
%\node[left=5 of z] (ln1) {level0} 
%    child {node (ln2) {level1} edge from parent [draw=none]
%        child {node (ln3) {level2} edge from parent [draw=none]
%            child {node (ln4) {} edge from parent [draw=none]
%                child {node (ln5) {level leaves} edge from parent [draw=none] }}}}; 
%
%% punkte zw leaves
%%\path (b12.north east) -- (g11.north west) node [midway] {$\cdots$};
%%\path (e12.north east) -- (f11.north west) node [midway] {$\cdots$};
%
%\coordinate (cd1) at ($(f12)+(1,0)$);
%\coordinate (nb1) at ($(g12)!.5!(e11)$);
%
%% RECHTE Seite Pfeil+Label1
%\draw[thick,<->,] 
%% near start: platziert Label1 unten, fill=white: Linie wird unterbrochen für Label1
%    (cd1) -- (cd1|-z.east) node [near start, fill=white] {Label1};
%
%\draw[dashed,thick] % dotted line from cn (root) --> cn (left side)
%    ($(z.west)+(-1em,0)$) -- (ln1);
%\draw[dashed,thick,->] % % blue dotted line from cn/2 --> cn (left
%    ($(a.west)+(-1em,0)$) -- (ln2.east);
%%\draw[blue!70!black,dashed,thick,->]    
%%    ($(b.west)+(-1em,0)$) -- (ln3);
%%\draw[blue!70!black,dashed,thick,->]    
%%    ($(b11.west)+(-1em,0)$) -- (ln5);
%
%\draw[thick,decorate,decoration={brace,amplitude=10pt,mirror},-,-{latex[flex=1pt]}] (b11.south west) -- (f12.south east); % curly bracket at leaves!
%
%\end{tikzpicture}
%\caption{This is an example tree.}
%\label{img:example_tree}
%\end{figure}
% ---------------- END EXAMPLE GRAPH ---------------------------

% Additional XMSS stuff:
% For further details on the security model of XMSS, we refer to [21] and for further security notions for the defined constructions, we refer to [5].-> fabios paper
% Explain difference: LMS vs XMSS (coll.res of hashfct not necessary)
% XMSS^MT: a multi-tree variant of XMSS -> maybe explain here

% ganz am Ende: Übersichtstabelle zu allen Zeit/Speicheraufwandszeiten
% MSS key pair generation requires the computation of 2^d one-time key pairs and 2^(d+1)-1 evaluations of the hash function.
% WOTS keygen+sign+verify time / aufwand / speicherverbrauch -> Positiv: Wenig Speicherverbrauch, kleinere Signatur als bei Lamport-Diffie!

% Facts Merkle-Tree:
% - Each public key (== root of the tree) can only be used to sign fixed number of messages - typically 2^n (weil 2^d = #Blätter von Baum mit Höhe d)
% + public key: short, only one hash value
% - signature size: huge, contains d public keys (für jede Höhe des Baumes eine, ein a_i + die one-time signatur an sich)
% - Berechnung public key (root): berechnen + speichern von 2^n ots-keys -> vlt kürzer mit treehash algo
% -> tradeoff zw. speicher+zeit: private keys S_i, deterministisch von kurzem secret seed S. Wenig Speicher für seed benötigt, dafür Zeit für Berechnung von secret keys->signature generation benötigt

	