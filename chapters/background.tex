\chapter{Background}
\label{cha:background}
This chapter addresses the scientific background needed for this work. First, the general concept of digital signature systems and hash functions are elaborated. Afterwards, the most common concepts for hash-based digital signature systems are explained. The presented hash-based schemes are the \textit{Lamport-Diffie one-time signature scheme~(LD-OTS)}, the \textit{Winternitz one-time signature scheme~(W-OTS)}, the \textit{Merkle signature scheme~(MSS)} and the \textit{extended Merkle signature scheme~(XMSS)}.

\section{Digital Signature Schemes}
% ! digital signature scheme -> assymetris ch (immer?) 
A \textit{digital signature scheme} uses a set of rules and a set of parameters to verify the identity of the originator, the integrity of data and non-repudiation.~\cite{cha:bg_digital_sign_schemes_NIST_standard1992} 
% Non-repudiation: It prevents an entity from denying previous commitments or actions.
% Integrity: Guarding against improper information modification or destruction, and includes ensuring information non-repudiation and authenticity -> https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-18r1.pdf
% -> desrcibe in table/more specific, what integrity/non-repudiation/etc. means
% -> description already in the following textblock, maybe put in table for overview?

In this section, for explanatory reasons, data refers to a message being sent from one sender to a recipient across a network (e.g. LAN). The sender is the person signing the message, the recipient usually wants to verify the received message, therefore they are referred to as signer and verifier. Notably, the verifier can also be a third party, not just the recipient.
The \textit{digital signature~$\sigma$} of a message, generated by a digital signature scheme, is a value dependent on some secret known only to the signer (usually the private key~$X$) and on the content of the message being signed. With the corresponding public key~$Y$ (without having access to the signer's private key $X$) the authenticity of the signature can be verified: It is ensured that the message actually belongs to the signer - e.g. a lying signer trying to repudiate their signature, a fraudulent claimant arguing the message is theirs, or a message that has been tampered with can be detected.
% hier vlt Bild von Signatursystem?
% hier schutzziele erwähnen (vlt Liste?) -> recipient will bestätigung das nachricht wirklich vom empfänger, sender will dass recipient ihm keine falschen nachrichten unterschiebt -> oder Schutzziele schon im 1. Satz
To ensure the above mentioned properties of digital signatures, a digital signature scheme consists of the following parts (see also Figure~\ref{img:digital_sign_system_simple}):~\cite{cha:bg_signature_schemes_book_menezes2018_1997} % gehört keygen wirklich zu signatursystem? -> ganze section beruht auf diesem Buch, wird das klar?

\begin{figure}
\centering
\includegraphics[width=\linewidth]{images/Background/Digital_Signaturesystem_Simple.png}
\caption{The general structure of a digital signature system. %Elke: Nur den ersten Satz als caption. Das hier nicht: The key generation algorithm creates the private key~$X$ and public key~$Y$, whereas $X$ is only known to the signer and $Y$ is made public for the verifier. The signer creates the message $M$ and signs it with the private key, using the signature generation algorithm. Afterwards, the so generated signature~$\sigma$ and the corresponding message~$M$ are sent to the verifier. The verifier checks the validity of the message and the corresponding signature with the public key (that is already known after key generation and distribution) and the verification algorithm. If the verification algorithm evaluates returns a valid result, the verifier can trust the message or otherwise knows it has been tempered with).
}
\label{img:digital_sign_system_simple}
\end{figure} 

\begin{enumerate}
\item The \textit{key generation algorithm} creates a private key~$X$ used for signature generation, and a public key $Y$ used by the recipient for signature verification. Both keys are mathematically dependent from each other, in which way is determined by the specific type of signature scheme (e.g. the Winternitz signature scheme, see Section~\ref{sec:WOTS_keygen}). % und auch noch von weiteren Leuten die Originalität von Nachricht prüfen wollen? Aber in meinem runtergebrochenen Beispiel nur 2 Leute, außerdem wird nicht erklärt dass auch key signiert wird
\item The \textit{signing algorithm} creates the digital signature~$\sigma$ of a message dependent on the private key $X$ of the signer and the content of the message.
\item The \textit{verification algorithm} is used by the verifier to check the validity of the signature~$\sigma$ and the corresponding message with the public key $Y$.
\end{enumerate}
% Y muss vor signieren der Nachricht veröffentlich werden

% Bild / Schema einfügen

% es wird message digest signiert
% Überleitung zu Hashfunctions

\section{Definition of Hash Functions} 
The security of the following presented \textit{One-Time Signature Schemes} (see section~\ref{sec:one-time_sign_schemes}) %Elke: Man könnte auch sagen, dass Signaturverfahren i. Allg. Hashfunktionen verwenden ...
is based on cryptographic secure hash functions. A hash function is a function that can be computed efficiently and maps strings of arbitrary length to strings of fixed length~\cite{cha:bg_hashfunctions_thesis_matusiewicz2007}. Therefore, a hash function $h$ is defined as any function $h$ with arbitrary length input to a fixed length output: $h: \{0,1\}^* \rightarrow \{0,1\}^n$~\cite{cha:bg_hashfunctoins_Stinson2006}. A hash function is considered \textit{cryptographically secure} if it has the following  properties:~\cite{cha:bg_hashfunctions_BASIC_DEFINITIONS_Springer2004} 

\begin{enumerate} % vlt: ? -> in x umbenennen in Zeichnungen + x in text auch blau machen damit klar ist, dass es das gesuchte ist
	\item \textbf{Preimage-Resistance / One-wayness}
	 A hash function $h$ is preimage-resistant if given an output value $y$, it is computationally infeasible to find any input which generates this output, i.e. finding any preimage $x$ such that $h(x) = y $ (when given any $y$). 

\begin{minipage}[t]{.5\linewidth}
          	\raggedright
            \includegraphics[width=.8\linewidth]{images/Background/preimage_res_horizontal.png}
	      \end{minipage} 

	\item \textbf{Second Preimage-Resistance}
	A hash function $h$ is second preimage-resistant, if given any input value and the corresponding output, it is computationally infeasible to find another distinct
input that produces the same output, i.e. given any $x$ finding a second preimage $x \neq x'$ such that $h(x) = h(x')$. % oder erst formel -> dann beschreibung dran?

\begin{minipage}[t]{.6\linewidth}
          	\raggedright
            \includegraphics[width=.8\linewidth]{images/Background/second_preimage_res_horizontal.png}
	      \end{minipage} 
	
	\item \textbf{Collision Resistance}
	A hash function $h$ is called collision-resistant, if it is computationally infeasible to find a pair of different inputs $x, x'$ that map to the same output value, such that $h(x) = h(x')$.


\begin{minipage}[t]{.6\linewidth}
          	\raggedright
            \includegraphics[width=.8\linewidth]{images/Background/collission_res_horizontal.png}
	      \end{minipage}
	      
\end{enumerate}	      


\section{One-Time Signature Schemes}
\label{sec:one-time_sign_schemes}
This section is based on the work of Buchmann et al~\cite{book_pqc_bernstein_2004}. 
% ONE-Time Signature scheme anmerken / erklären
The two signature schemes Lamport-Diffe and Winternitz are both \textit{one-time signature schemes (OTS)}, meaning the public and private key can be used \textbf{once}, for signing a single message. If they are used for generating more than one signature, the signature can be forged. % vlt rauslöschen einfach
The following types of functions are used for the Lamport-Diffie One-Time Signature Scheme and the Winternitz One-Time Signature Scheme: 
The cryptographic hash function~$h$ is preimage resistant, second preimage-resistant and collision resistant, it is applied to the original message and generates the message digest.
The one-way function~$f$ is a hash function that is at least preimage-resistant and takes a fixed input length, because it is applied to the message digest.% später wird Benutzung von h und f noch sichtbar
% hier erklären was one time signature scheme ist & dass LD-OTS und Winternitz-OTS erklärt werden

\begin{equation}
\label{eq:basic_hashfunc}
\textbf{Cryptographic hash function h: } \lbrace 0,1 \rbrace^* \rightarrow \lbrace 0,1 \rbrace^n
\end{equation}

\begin{equation}
\label{eq:one-way-func}
\textbf{One-way function f: } \lbrace 0,1 \rbrace^n \rightarrow \lbrace 0,1 \rbrace ^n
\end{equation}


\subsection{Lamport-Diffie One-Time Signature Scheme (LD-OTS)}
The Lamport–Diffie one-time signature scheme (LD-OTS) was first proposed by Leslie Lamport in 1979~\cite{lamport_signature_scheme_1979}. 

\subsubsection{LD-OTS Key Generation}
The private key X consists of $2n$ bit strings, each of length $n$, chosen at random. As the key size and signature size are dependent on $n$, it is also referred to as security parameter.
% n ist security parameter
% !! einfügen, was n für eine Rolle spielt

\begin{equation}
\label{eq:ldots_sign_key}
X = \left(x_{0}\left[0\right], x_{0}\left[1\right], x_{1}\left[0\right], x_{1}\left[1\right], \cdots, x_{n-1}\left[0\right], x_{n-1}\left[1\right] \right)
\end{equation}
The public key $Y$ is created out of the private key $X$. For each $x_i[j] \in X, 0 \leq i \leq n-1, j \in \lbrace 0,1 \rbrace$, the one-way function~f (see Equation~\ref{eq:one-way-func}) is applied.

\begin{equation}
y_i[j] \in Y = f(x_i[j]), 0 \leq i \leq n-1, j \in \lbrace 0,1 \rbrace
\end{equation}

\begin{equation}
Y = \left( 
y_{0}\left[0\right], y_{0}\left[1 \right], y_{1}\left[0\right], y_{1}\left[1\right], \cdots, y_{n-1}\left[0\right], y_{n-1}\left[1\right]
\right)
\end{equation}

\subsubsection{LD-OTS Signature Generation} % m has fixed length
Before signing, the public key $Y$ has to be published.
The private key $X$ (see Equation~\ref{eq:ldots_sign_key}) is used to sign the message $M \in \lbrace 0,1 \rbrace^*$. 
The cryptographic hash function $h$ (see Equation~\ref{eq:basic_hashfunc}) is applied to $M$ in order to get the hash digest $m$ of fixed length $n$.

\begin{equation}
\label{eq:hash_message}
m = h(M) = (h_{0}, \cdots, h_{n-1})
\end{equation} % Elemente von m ENTWEDER m_i ODER h_i
For each bit $h_i \in m$, the corresponding $x_i[h_i]$ out of private key $X$ is chosen, resulting in signature $\sigma$ for message $m$.
% h_i in m_i umbenennen oder umgekehrt -> konsequent bleiben
\begin{equation}
\sigma = \left(
x_0 \left[ h_0 \right], x_1\left[ h_1 \right], \cdots, x_{n-1}\left[ h_{n-1}\right]
\right) = (\sigma_0, \cdots, \sigma_{n-1})
\end{equation}

\subsubsection{LD-OTS Verification}
After receiving a message $M$ with the corresponding signature $\sigma$, the verifier calculates the message digest $h(M) = m$. 
To verify the given signature $\sigma$, it is necessary to check the following condition.
\begin{equation}
\left(
f(\sigma_0), \cdots, f(\sigma_{n-1})
\right) =
\left(
y_0[h_0], \cdots, y_{n-1}[h_{n-1}]
\right)
\end{equation}
If the condition is true, the signature is valid.

% nochmal extra auf Einmalverwendung hinweisen
% table with properties i.e.
% keygen+sign+verify time / aufwand / speicherverbrauch -> Positiv: schnelle signatur+keygen Negativ: Viel Speicherverbrauch
% Überleitung zu Winternitz weil diese Vorteil kürzerer Signatur aufweisen

\subsection{Winternitz One-Time Signature Scheme (W-OTS)}
LD-OTS signatures are efficient to calculate but have a huge size. % somewhere else explain that huge signature -> need much "memory"-> bad ? or is it obvious
The Winternitz one-time signature scheme (W-OTS) generates signatures with substantially shorter size. W-OTS uses the same hash function (Equation~\ref{eq:basic_hashfunc}) and one-way function (Equation~\ref{eq:one-way-func}) as LD-OTS. %genauer beschreiben evtl

\subsubsection{W-OTS Key Generation}
\label{sec:WOTS_keygen}
First, two parameters are selected: The Winternitz-Parameter $w \geq 2$ and the security parameter $n$. When increasing $w$, the signature size will decrease linearly and the effort for key generation, signing and verification will increase exponentially. As $n$ is the length of the message digest, increasing it leads to higher security because it increases the collision resistance of the hash function. % weil mehr Winternitz-Ketten generiert werden, je kleiner w ist, reduziert ein hohes w die Signaturgröße
% The Winternitz parameter w enables space/time trade-offs.

% bezieht sich auf #stücke in die m geteilt wird
\begin{equation}
\label{eq:t1}
t_1 = \ceil[\Bigg]{\frac{n}{w}}
\end{equation}

% bezieht sich auf #stücke in die checksum geteilt wird
\begin{equation}
\label{eq:t2}
t_2 = \ceil*{\frac{\floor*{\log_2 t_1} + 1 + w}{w} }
\end{equation}

% anzahl stücke von signatur M || C am ende
\begin{equation}
\label{eq:t}
t = t_1 + t_2
\end{equation}
The private key $X$ consists of $t$ bit strings, each of length $n$ chosen at random.

\begin{equation}
\label{eq:wots_privkey}
X = (x_0, \cdots, x_{t-1})
\end{equation}
The public key $Y$ is generated by applying the one-way function~$f$ to each element $x_i  \in X$  consecutively $2^w - 1$ times. % hier sieht man dass höheres w -> höherer Aufwand Keygen

\begin{equation}
\label{eq:wots-generation-one-time-public-key}
y_i \in Y =  f^{2^w-1}(x_i), 0 \leq i \leq t-1 
\end{equation}

\begin{equation}
Y = (y_0, \cdots, y_{t-1})
\end{equation}
Each $y_i \in Y$ is a bit string of length $n$. The public key $Y$ has to be published before the signature can be generated. One value of the public key is corresponding to one full \textit{Winternitz chain}. % maybe introduce Winternitz chain another way?

\subsubsection{W-OTS Signature Generation}
For signing a message $M \in \lbrace 0,1 \rbrace^*$, the cryptographic hash function~h (see Equation~\ref{eq:basic_hashfunc}) is applied to $M$ (see Equation~\ref{eq:hash_message}). The resulting hash digest $m$ is split into $t_1$ bitstrings of length $w$. If $m$ is not divisible by $w$, it is necessary to add leading zeros to $m$ before splitting.

\begin{equation}
\label{eq:hash_digest_split}
m = m_0 \concat m_1 \concat \cdots \concat m_{t_1-1}
\end{equation}
Each bitstring $m_i \in m$ is converted to its decimal representation in order to calculate the checksum $c$. A detailed example why the checksum is necessary is shown at section~\ref{sec:checksum_explained}. % ! reference to subsubsection doesn't work: https://tex.stackexchange.com/questions/198800/how-to-number-and-cross-reference-subsubsection-level-headers and https://blog.chapagain.com.np/latex-numbering-subsubsection-and-showing-it-in-table-of-contents/

\begin{equation}
\label{eq:checksum_calculation}
c = \sum_{i = 0}^{t_{1}-1}(2^w-m_i)
\end{equation}
The checksum $c$ is divided into $t_2$ bitstrings of length $w$. In order to divide $c$ this way, it can be necessary to add leading zeros to $c$ as a padding.
\begin{equation}
c = c_0 \concat c_1 \concat \cdots \concat c_{t_2 - 1}
\end{equation}
Afterwards, $m$ and $c$ are concatenated to one block~$B$. This leads to $t$ bitstrings of length $w$ in total, as $t = t_1 + t_2$.

\begin{align}
\label{eq:block_B_out_of_M_and_C}
B &= m \concat c  \\ 
&= m_0 \concat \cdots \concat m_{t_1 - 1} \concat c_0 \concat \cdots \concat c_{t_2 - 1} \nonumber \\
&= b_0 \concat \cdots \concat b_{t-1} \nonumber
\end{align}
The signature $\sigma$ is calculated by applying the one-way function~$f$ to each part of the private key $X$ (see Equation~\ref{eq:wots_privkey}) several times: The element $b_i \in B$ determines the amount of times the hash function $f$ is applied to the corresponding $x_i \in X$. One element of the signature is also referred to as one \textit{Winternitz chain}.

\begin{equation}
\sigma = (f^{b_0}(x_0), f^{b_1}(x_1), \cdots, f^{b_{t-1}}(x_{t-1})) = (\sigma_0, \cdots, \sigma_{t-1})
\end{equation}

\subsubsection{W-OTS Verification}
\label{cha:wots-verification}
Given a signature $\sigma$ and message $M$, the hash digest $m$ is generated (see Equation~\ref{eq:hash_message}). Afterwards, the block $B$ is generated out of~$m$ as shown in the previous section (see Equations~\ref{eq:hash_digest_split} to~\ref{eq:block_B_out_of_M_and_C}). To check if the given signature is valid, the one-way function~$f$ is applied $2^w - 1 - b_i$ times to each $\sigma_i \in \sigma$. The result is compared to the corresponding $y_i \in Y$. This can also be described as advancing each Winternitz chain in the signature by applying~$f$, until the  values of the public key are reached.

\begin{equation}
(f^{(2^w-1)-b_0}(\sigma_0), \cdots, f^{(2^w - 1) - b_{t-1}}(\sigma_{t-1})) \? (y_0, \cdots, y_{t-1})
\end{equation}
If each $f^{2^w-1-b_i}(\sigma_i) = y_i$, the signature is valid because $\sigma_i = f^{b_i}(x_i)$ and therefore

\begin{gather}
f^{2^w-1-b_i}(\sigma_i) = f^{2^w-1}(x_i) = y_i \\
0 \leq i \leq t-1 \nonumber
\end{gather}

\subsubsection{W-OTS Example Calculation}
\label{sec:w-ots_example_calc}
This section contains an example calculation of W-OTS, including key generation, signature generation, and signature verification.
% ! explain that example one-way function is not cryptographic secure, is only example

\begin{enumerate}

\item The first step is choosing the following parameters:
$n=3, w=2, \text{message digest } m = 101, {\text{one-way function } f:\{0,1\}^{3} \rightarrow \{0,1\}^{3}, x \rightarrow x+2 \text{ mod } 8}$

% ceilings of t_2 are a bit ugly. Maybe fix later
\item Calculating $t_1, t_2, t$: \\
$t_1 = \ceil{\frac{n}{w}} = \ceil{\frac{3}{2}} = 2, t_2 = \ceil*{\frac{\floor*{\log_2 t_1} + 1 + w}{w} } = \ceil*{\frac{\floor*{\log_2 2} + 1 + 2}{2} } = 2, {t = t_1 + t_2 = 2+2 = 4}$

\item Choosing the private key $X$ with $t=4$ random bit strings of length $n=3$: \\
$X = (x_0, \cdots, x_{t-1}) = (x_0, x_1, x_2, x_3) = 
\begin{psmallmatrix}
1 & 1 & 0 & 1\\
0 & 1 & 1 & 1\\
1 & 1 & 1 & 0
\end{psmallmatrix} \in \{0,1\}^{(3,4)} $

\item Calculating the public key $Y$ from $X$ by applying $f$ to each element in $X$ for $2^w-1 = 3$ times:	
$Y = (y_0, \cdots, y_{t-1}) = (y_0, y_1, y_2, y_3) = 
\begin{psmallmatrix}
0 & 1 & 0 & 1 \\
1 & 0 & 0 & 0 \\
1 & 1 & 1 & 0
\end{psmallmatrix} \in \{0,1\}^{(3,4)} $ 

\item To make $m$ divisible by $w$, a leading zero is inserted. Then it is split in blocks of length $w$: $m = 01 \concat 01 = m_0 \concat m_1$. These blocks are used for the checksum calculation: \\ $c = (2^w - m_0) + (2^w - m_1) = (4-1)+(4-1)=6$. To make $c$ divisible by $w$ as well, one leading zero is added to the binary representation of $c$. Then, splitting $c$ in blocks of length $w$ yields $c = 01 \concat 10 = c_0 \concat c_1$.

\item The block $B$ is generated by concatenating $m$ and $c$: \\ $B = m_0 \concat m_1 \concat c_0 \concat c_1 = b_0 \concat b_1 \concat b_2 \concat b_3 = 01 \concat 01 \concat 01 \concat 10 $.

\item %The signature $\sigma$ is created by applying $f$ to each element in $X$.
%The block $B$ determines the amount of applying $f$ to $X$
The signature $\sigma$ of $m$ is determined by the parameter $B$ and one-way function $f$: \\ % hier besser erklären dass man dezimalrepr. von B und X nimmt?
$\sigma = (f^{b_0}(x_0), f^{b_1}(x_1),f^{b_2}(x_2),f^{b_3}(x_3)) = (f^1(5),f^1(7),f^1(3),f^2(6)) = (\sigma_0, \sigma_1, \sigma_2, \sigma_3) = 
\begin{psmallmatrix}
1 & 0 & 1 & 0 \\
1 & 0 & 0 & 1 \\
1 & 1 & 1 & 0
\end{psmallmatrix} \in \{0,1\}^{(3,4)} $

\item The verifier knows $Y, w, n$ and therefore $t_1, t_2$ and $t$. After receiving $m, \sigma$ from the signer, the block $B$ is calculated as explained in the previous steps. The validity of the signature $\sigma$ is checked by calculating: \\
$( f^{2^w-1-b_0}(\sigma_0), f^{2^w-1-b_1}(\sigma_1), f^{2^w-1-b_2}(\sigma_2), f^{2^w-1-b_3}(\sigma_3)) = (f^2(7) , f^2(1), f^2(5), f^1(2)) = \begin{psmallmatrix}
0 & 1 & 0 & 1 \\
1 & 0 & 0 & 0 \\
1 & 1 & 1 & 0
\end{psmallmatrix} \in \{0,1\}^{(3,4)} $
\\ Because these values are the same as in the public key $Y$, $\sigma$ is valid. 

\end{enumerate}

\subsubsection{W-OTS Checksum Example}
\label{sec:checksum_explained}
In this section, the necessity of the W-OTS checksum (see also Equation~\ref{eq:checksum_calculation}) is explained with an example. 
The attack prevented by the checksum is an \textit{adaptive chosen-message attack}: It is possible for the attacker to generate new messages with matching signatures which depend on previously obtained signatures and messages~\cite{cha:bg_signature_schemes_book_menezes2018_1997}. 
After obtaining a message and corresponding signature, the idea behind the attack is to increase the bits of the received message to generate a new message. The hash function is applied respectively to the corresponding digits in the signature, increasing the Winternitz chain. Then, without the checksum, a new valid signature would be generated for the message. For this example, the same parameters for W-OTS are used as in the the section before. % (see section~\ref{sec:w-ots_example_calc}. again_: need correct subsubsection label

\begin{enumerate}
\item We assume the attacker knows the message digest $m = 101$, the corresponding signature $\sigma = (\sigma_0, \sigma_1, \sigma_2, \sigma_3)$ and the parameters $w=2, n=3, Y, f$ of the example in the section before. The attacker can get this information because a digital signature system does not ensure confidentiality of the message or the parameters, the premise is the secrecy of the private key. The goal of the attacker is to forge a signature $\sigma' = (\sigma_0', \sigma_1', \sigma_2', \sigma_3')$ to get a valid signature for a message $m'$ chosen by the attacker. 
% (e.g. the attacker was also the receiver of the message or intercepted the channel where the message was sent)

\item The attacker calculates $m  = m_0 \concat m_1 = 01 \concat 01$, $c = c_0 \concat c_1 = 01 \concat 10$ and therefore $B =  b_0 \concat b_1 \concat b_2 \concat b_3 = 01 \concat 01 \concat 01 \concat 10$ (see steps 1-6 in section before).

\item The original message $m = 101$ is increased by one: $m' = 111$. Make $m'$ divisible by $w = 2$, insert leading zero: $m' = m_0'\concat m_1' = 01 \concat 11$. Calculate checksum $c' = (2^w - m_0') + (2^w - m_1') = (4-1)+(4-3)=4$.
Insert leading zero to $c'$ to make it divisible by $w$: $c' = c_0' \concat c_1' = 01 \concat 00$. Therefore, $B' = b_0' \concat b_1' \concat b_2' \concat b_3' = 01 \concat 11 \concat 01 \concat 00$.

Now, the attacker can forge $\sigma_0', \sigma_1'$ of the signature $\sigma'$:
As $b_0 = b_0' = 01$, $\sigma_0' = \sigma_0$.
Because the difference between $b_1 = 01$ and $b_1' = 11$ is $2$, applying $f$ two more times to $\sigma_1$ leads to $\sigma_1'$: $f^2(\sigma_1) = \sigma_1'$.

Notably, $\sigma_0, \sigma_1$ depend only on the message bits $m_0, m_1$, not on the checksum. Therefore, the attacker could forge a signature for $m'$ without the checksum. But because of the checksum bit $c_3 = b_3 = 10, c_3' = b_3' = 00$, $b_3 > b_3'$, it is not possible to calculate $\sigma_3$: The attacker would have to calculate $f^{-2}(\sigma_3)$, that is finding two times a preimage to $\sigma_3$. As long as the hash function $f$ is preimage resistant, which is assumed (see also Equation~\ref{eq:one-way-func}), this is not possible. The attacker can not forge the complete signature $\sigma'$.

\end{enumerate}
For a general proof of security of the checksum, see Section 9.3 in McGrew et al.~\cite{LMS_RFC8554}.
For LD-OTS, the checksum is not necessary because only one hash function call is used to get to the public key $Y$. Therefore, it is not possible to generate another valid signature $\sigma'$ by applying the hash function to the known signature $\sigma$ again.

%For a general proof, see https://datatracker.ietf.org/doc/html/rfc8554#section-9.3

% Why checksum is necessary: This checksum is needed because an attacker can freely advance any of the Winternitz chains.  That is, if this checksum were not present, then an attacker who could find a hash that has every digit larger than the valid hash could replace it (and adjust the Winternitz chains).-> citation: RFC of LMS (https://www.rfc-editor.org/rfc/rfc8554.html#section-4)
% genaue beschreibung checksum bsp angriff: https://datatracker.ietf.org/doc/html/rfc8554#section-9.3
% https://crypto.stackexchange.com/questions/31696/winternitz-signature-in-standard-model -> stackoverflow frage + antwort genau dazu

\section{Merkle Signature Scheme (MSS)} 
\label{sec:mss}
%!! Zitierung fehlt von Buchmann
The main disadvantage of the one-time signature schemes introduced in Section~\ref{sec:one-time_sign_schemes} is the restriction to use each key pair (consisting of private key~$X$ and public key~$Y$) for only one signature. This is inadequate for most practical situations, because the key generation as well as the key distribution take a lot of time and effort that could be saved otherwise.
To solve this problem, Merkle~\cite{cha:bg_merkletrees_Merkle_1979} proposed the concept of using a binary hash tree, where each leaf represents a different one-time key pair, the \textit{Merkle Signature Scheme (MSS)}. The root of the tree is the public key $Y_{MSS}$  which combines the one-time key pairs at the leafs. With a tree depth $d$, $2^d$ one-time key pairs and corresponding signatures can be generated. % achtung: bei RSA mehr, possibly unendlich
This concept is denoted as \textit{Merkle signature scheme (MSS)} and it works with any cryptographic hash function and any one-time signature scheme. 
The structure of the Winternitz one-time signature scheme fits better into MSS than the Lamport-Diffie one-time signature scheme: When using W-OTS, it is not necessary for the signer to put the public one-time signature key $Y_s$ in the one-time signature $\sigma_s$. The verifier will automatically calculate $Y_s$ from the given one-time signature. Therefore, the chosen one-time signature scheme for MSS in this chapter is W-OTS. The cryptographic hash function~$h$ (see Equation~\ref{eq:basic_hashfunc}) is used. 
% Moreover, when using LD-OTS: All X_s (for signature) + corresponding Y_s are needed. Not enough when verifier knows only the X_s that are needed for OTS-signature, moreover the rest of Y_s are needed (because all "leaves" are needed) to build the merkle tree.

\subsection{MSS Key Generation}
\label{cha:mss_keygen}
For a depiction of the Merkle tree referenced in this section, see Figure~\ref{img:merkle_tree}.
The signer chooses the tree depth~$d$ where $d \geq 2$, and generates $2^d$ one-time key pairs $(X_j, Y_j)$ where $0 \leq j \leq 2^d-1$, with $X_j$ being the private key and $Y_j$ the corresponding public key. The \textit{leaves} of the Merkle tree are the hash digests $H_{i,j}$ of the public key $Y_j$.
\begin{gather}
\label{eq:leaf_merkle_tree:hash_digest_publ_key_Y}
H_{i,j} = h(Y_j) \\ 
0 \leq j \leq 2^d - 1 \nonumber
\end{gather}
The \textit{inner nodes} of the Merkle tree are computed as follows: Each parent node $H_{i,j}$ is the hash digest of the concatenation of its direct two children: % $H_{i+1,j}$ and $H_{i+1,j+1}$.

% ! wichtig dass 0 <= i < d weil Blätter zählen nicht mit
\begin{gather}
\label{eq:inner_nodes_merkle_tree_keygen}
H_{i,j} = h(H_{i-1,2j} \concat H_{i-1,2j+1}) \\
1 \leq i \leq d \nonumber \\ 
0 \leq j < 2^{d - i} \nonumber
\end{gather} 
The \textit{root} of the Merkle tree is the MSS public key~$Y_{MSS}$. The MSS private key~$X_{MSS}$ is the collection of one-time signature keys generated before constructing the Merkle tree.
% Y_mss = H_d,0 because d=height of tree
\begin{align}
\label{eq:xmss_priv_key}
X_{MSS} &= (X_0, \cdots, X_j, \cdots, X_{2^d - 1} ) \\
Y_{MSS} &= H_{d,0} \nonumber
\end{align}
The signer publishes the public key $Y_{MSS}$.

\begin{figure}
\centering
% unsichtbare Kante: edge from parent[draw=none]
\begin{tikzpicture} 
[
    level 1/.style = {sibling distance = 8cm},
    level 2/.style = {sibling distance = 4cm},
    level 3/.style = {sibling distance = 2.5cm},
    level 4/.style = {level distance = 1cm, color = grey_tud}
]
\node {$H_{3,0} = h(H_{2,0} \concat H_{2,1}) = Y_{MSS}$}
	child { node {$H_{2,0} = h(H_{1,0} \concat H_{1,1})$} 
		child { node {$H_{1,0} = h(H_{0,0} \concat H_{0,1})$}
			child{ node {$H_{0,0} = h(Y_0)$}
				child{ node {$Y_0$} edge from parent[<-]
					child{ node {$X_0$} edge from parent[<-,dashed] 
					}
				}	
			}
			child{ node {$H_{0,1} = h(Y_1)$}
				child{ node {$Y_1$} edge from parent[<-]
					child{ node {$X_1$} edge from parent[<-,dashed] 
					}
				}			
			}		
		} 
		child { node {$H_{1,1}$}
			child{ node {$H_{0,2}$}
				child{ node {$Y_2$} edge from parent[<-]
					child{ node {$X_2$} edge from parent[<-,dashed] 
					}					
				}			
			}
			child{ node {$H_{0,3}$}
				child{ node {$Y_3$} edge from parent[<-]
					child{ node {$X_3$} edge from parent[<-,dashed] 
					}
				}			
			}		
		}	
	}
	child { node {$H_{2,1}$} 
		child { node {$H_{1,2}$}
			child {node {$H_{0,4}$}
				child{ node {$Y_4$} edge from parent[<-]
					child{ node {$X_4$} edge from parent[<-,dashed] 
					}
				}			
			}
			child {node {$H_{0,5}$}
				child{ node {$Y_5$} edge from parent[<-]
					child{ node {$X_5$} edge from parent[<-,dashed] }
				}			
			}		
		}
		child { node {$H_{1,3}$}
			child {node {$H_{0,6}$}
				child{ node {$Y_6$} edge from parent[<-]
					child{ node {$X_6$} edge from parent[<-,dashed] 
					}
				}			
			}
			child {node {$H_{0,7}$}
				child{ node {$Y_7$} edge from parent[<-]
					child{ node {$X_7$} edge from parent[<-,dashed] 
					}
				}			
			}
		}	
	}
	;
\end{tikzpicture} % klarmachen dass h1,1 = hash(h2,1|h2,2) usw
\caption{Merkle tree of depth $d=3$. The composition of the tree is depicted in detail on the left branch, each node consists of the hash digest of its concatenated children (see Equation~\ref{eq:inner_nodes_merkle_tree_keygen}). The leafs are the hash digests of their corresponding \textcolor{grey_tud}{one-time public key} (see Equation~\ref{eq:leaf_merkle_tree:hash_digest_publ_key_Y}). Because W-OTS is used, the signer generates the \textcolor{grey_tud}{public one-time keys} by applying the hash function~$h$ for $2^w-1$ times to the corresponding \textcolor{grey_tud}{private one-time keys $X_i \in X_{MSS}$} (see Equations~\ref{eq:wots-generation-one-time-public-key} and~\ref{eq:xmss_priv_key}).}
\label{img:merkle_tree}
\end{figure}
% soll treehash algo hier auch erklärt werden?

\subsection{MSS Signature Generation}
\label{sec:mss_sig_gen}
For a depiction of the Merkle tree referenced in this section, see Figure~\ref{img:merkle_tree_signature_gen}. 
To sign a message $M$, the signer needs to generate the signature $\sigma_s$.
First, the hash digest $m = h(M)$ of length $n$ (see Equation~\ref{eq:hash_message}) is calculated. Then, by using the chosen one-time signature scheme W-OTS, the one-time signature $\sigma_{s/OTS}$ of $m$ is generated with a one-time key $X_s, s \in \{0, \cdots, 2^d - 1\}, X_s \in X_{MSS}$. % somehow: move "s is part of the signature" here / as first sentence, makes more sense than mentioning that it's part of the signature later

\begin{equation}
\label{eq:merkle_s/OTS_signature}
\sigma_{s/OTS} \leftarrow_{sign} (X_s, m) 
\end{equation}
%\ "The corresponding $Y_s$ is also part of the signature" -> NICHT bei W-OTS, wovon man hier ausgeht. Verifier berechnet Y_s auf dem Weg zur vollen Winternitz-Kette, indem er signatur bekommt und "weiterhasht".
Additional information about the Merkle tree has to be included in $\sigma_s$: The index $s$ and the authentication path for the verification key $Y_s$. The authentication path $A_s$ consists of a sequence of nodes $a_i$ in the Merkle tree:

% a_{d-1}, NOT a_{d} because this would be the root
% a_i vlt rausnehmen aus Sequenz?
\begin{equation}
A_s = (a_0,\cdots, a_i, \cdots, a_{d-1})
\end{equation}
Each node $a_i \in A_s$ is calculated as follows:
% !! floor probably also necessary for first equations
\begin{align}
\label{eq:auth_path_calculation_merkle_tree}
&a_{i} = H_{i, j} \\
&j = 
\left\{\begin{matrix} \nonumber
\floor{s/2^i}-1 \text{ if } \floor{s/2^i} \equiv 1 \mod{2} \\
\floor{s/2^i}+1 \text{ if } \floor{s/2^i} \equiv 0 \mod{2}
\end{matrix}\right.  \nonumber \\
&0 \leq i \leq d-1 \nonumber
\end{align}
In summary, one MSS signature contains the following elements:
% Ys not part of sigma_s?
\begin{equation}
\label{eq:complete_merkle_signature_for_one_Ys}
\sigma_s = (s,\sigma_{s/OTS}, A_s) 
\end{equation}

% ? path h2,0 - h1,0 and h1,1 - h0,0 also with arrows?
% in caption: "path from leaf to the root" not entirely correct, cyan nodes also part of the path?
\begin{figure}
\centering
% unsichtbare Kante: edge from parent[draw=none]
\begin{tikzpicture} 
[
    level 1/.style = {sibling distance = 8cm},
    level 2/.style = {sibling distance = 4cm},
    level 3/.style = {sibling distance = 2.5cm},
    level 4/.style = {level distance = 1cm}
    %level 5/.style = {level distance = 1.5cm}
]
\node [darkblue_tud] {$H_{3,0} = p_3 \? Y_{MSS}$ }
	child { node [darkblue_tud] {$H_{2,0} = p_2$ } edge from parent[<-]
		child { node [cyan_tud] {$H_{1,0} = a_1$} edge from parent[-, black]
			child{ node {$H_{0,0} = h(Y_0)$}
				child{ node {$Y_0$} edge from parent[<-]
					child{ node {$X_0$} edge from parent[<-, dashed] 
					}
				}	
			}
			child{ node {$H_{0,1}$}
				child{ node {$Y_1$} edge from parent[<-]
					child{ node {$X_1$} edge from parent[<-, dashed] 
					}
				}			
			}		
		} 
		child { node [darkblue_tud] {$H_{1,1} = p_1$}  edge from parent[<-]
			child{ node [cyan_tud]{$H_{0,2} = a_0$} edge from parent[-, black]
				child{ node {$Y_2$} edge from parent[<-]
					child{ node {$X_2$} edge from parent[<-, dashed] 
					}
				}			
			}
			child{ node [darkblue_tud] {$H_{0,3} = p_0$} edge from parent[<-]
				child{ node {$\textcolor{darkblue_tud}{Y_3}$} edge from parent[<-]
					child{ node {$\textcolor{cyan_tud}{\sigma_{3/OTS}}$} edge from parent[<-, dashed] 
						child{ node {$X_3$} edge from parent[<-, dashed] }
					}
				}			
			}		
		}	
	}
	child { node [cyan_tud] {$H_{2,1} = a_2$} 
		child { node {$H_{1,2}$}
			child {node {$H_{0,4}$}
				child{ node {$Y_4$} edge from parent[<-]
					child{ node {$X_4$} edge from parent[<-, dashed] 
					}
				}			
			}
			child {node {$H_{0,5}$}
				child{ node {$Y_5$} edge from parent[<-]
					child{ node {$X_5$} edge from parent[<-, dashed] 
					}
				}			
			}		
		}
		child { node {$H_{1,3}$}
			child {node {$H_{0,6}$}
				child{ node {$Y_6$} edge from parent[<-]
					child{ node {$X_6$} edge from parent[<-, dashed] 
					}
				}			
			}
			child {node {$H_{0,7}$}
				child{ node {$Y_7$} edge from parent[<-]
					child{ node {$X_7$} edge from parent[<-, dashed] 
					}
				}			
			}
		}	
	}
	;
\end{tikzpicture}
\caption{Example for Merkle signature generation and verification, tree depth $d=3$. The signer generates the Merkle tree and chooses $s=3$, then calculates the signature $\textcolor{cyan_tud}{\sigma_3 = (3, \sigma_{s/OTS},A_3)}$.
The nodes $H_{0,2}, H_{1,0}, H_{2,1}$ are in the \textcolor{cyan_tud}{authentication path $A_3 = (a_0, a_1, a_2)$}. After receiving $\sigma_3$, the verifier uses the one-time signature \textcolor{cyan_tud}{$\sigma_{3/OTS}$} to calculate $\textcolor{darkblue_tud}{Y_3}$ by applying the hash function $h$ a specific amount of times to it (see also Section~\ref{cha:wots-verification}).
Now, with the knowledge of $\textcolor{cyan_tud}{A_3}$ and $\textcolor{cyan_tud}{Y_3}$, the verifier can calculate the path \textcolor{darkblue_tud}{path $P_s = (p_0, p_1, p_2, p_3)$}, also indicated by the arrows. If the root $p_3$ calculated by the verifier matches the public key $Y_{MSS}$, the signature $\sigma_3$ is valid.}
\label{img:merkle_tree_signature_gen}
\end{figure}


\subsection{MSS Signature Verification}
When receiving $\sigma_s$ (see Equation~\ref{eq:complete_merkle_signature_for_one_Ys}), the verifier uses $\sigma_{s/OTS}$ to calculate $Y_s$. This works specifically because W-OTS is used in combination with the Merkle tree: Applying the hash function $h$ for a specific amount of times to $\sigma_s$ (this is determined by the underlying W-OTS, see section~\ref{cha:wots-verification}) automatically generates $Y_s$.
Because of the index $s$, the verifier knows the leaf-position of the calculated $Y_s$ in the Merkle tree. 
In combination with the authentication path $A_s$, the verifier can construct a path from the leaf $Y_s$ to the root of the Merkle tree: 

\begin{equation}
P_s = (p_0, \cdots, p_d)
\end{equation}
The path $P_s$ is constructed by using the index $s$ and the authentication path $A_s$:

\begin{align}
\label{eq:merkle_verifier_path_calculation}
&p_0 = h(Y_s) \\
&p_{i} = 
\left\{\begin{matrix} \nonumber
h(a_{i-1} \concat p_{i-1}) \text{ if } \floor{s/2^{i-1}} \equiv 1 \mod{2} \\
h(p_{i-1} \concat a_{i-1}) \text{ if } \floor{s/2^{i-1}} \equiv 0 \mod{2}
\end{matrix}\right.  \nonumber \\
&0 \leq i \leq d  \nonumber 
\end{align}
The verification of signature $\sigma_s$ is only successful if the root $p_d$ calculated by the verifier matches the public key $Y_{MSS}$. The one-time key $Y_s$ and therefore the one-time signature $\sigma_s/OTS$ are implicitly validated, as $Y_s$ is calculated "on the way" to the root of the Merkle tree by the verifier.
This section is also explained in detail with a depiction of the Merkle tree in Figure~\ref{img:merkle_tree_signature_gen}.

% \subsection{Leighton-Micali Signature Scheme (LMS)} -> move to state of the art?`
% insert description of LMS here / "this is basically LMS but LMS also has a seed"

%!!! https://eprint.iacr.org/2020/470.pdf : Example picture to show XMSS + L-trees

\section{Extended Merkle Signature Scheme (XMSS)}
The \textit{eXtended Merkle Signature Scheme (XMSS)}~\cite{xmss_RFC8391} is an extension of the Merkle Signature Scheme in combination with W-OTS. One of the main advantages of XMSS is that it does not rely on the collision resistance of the used hash functions, but on weaker properties (preimage-resistance, second preimage-resistance). This is achieved by using additional randomly chosen bitmasks in the Merkle tree (see Figure~\ref{img:example_xmss_minitree}) as well as in the Winternitz-chains (see Figure~\ref{img:example_wots+_bitmask}) for each invocation of the hash function. The Winternitz one-time signature scheme that now includes bitmasks is referred to as \textit{W-OTS+}. XMSS is a \textit{stateful} signature scheme, so the private key changes after every signature generation.
The notation of parameters used for XMSS in this work is shown in Table~\ref{table:xmms_param}.
% Maybe add this to "stateful": If a secret key state is used twice, no cryptographic security guarantees remain. (There exists a possibility to make digital signature system with underlying one-time signature scheme stateless - SPHINCS+.) -> or add to keygen

% Describe XMSS tree: Each non-leaf tree node is computed by first concatenating the values of its child nodes, computing the XOR with a bitmask, and applying the keyed hash function H to the result. 

%param for tree/xmss
% D = complete height of the tree (pubkeys WOTS+ as leaves)c -> necessary? leave out for now
% source https://eprint.iacr.org/2020/470.pdf
% l = number of Winternitz chains used in a single OTS operation -> ? why, check this
% maybe add: SEED (public), idx (Blatt index), w, n, hashfunctions...
\begin{table}
\begin{center}
\begin{tabular}{c l} 
 \hline
 symbol & meaning  \\ 
 \hline
 $n$ & security parameter. \\ 
 $w$ & Winternitz parameter  \\ 
 $d$ & height of Merkle tree in the XMSS tree  \\ 
 $l$ & number of Winternitz chains used in a single OTS operation / \\ 
     & amount of leaves of the L-Tree \\ 
 $\ceil{log(l)}$ & height of one L-Tree in the XMSS tree \\
% $D$ &  $D = l+d$, \\ 
%     &  height of the complete XMSS tree from W-OTS+ public keys to the root\\
 \hline
\end{tabular}
\caption{Symbols and parameters used for describing XMSS.}
\label{table:xmms_param}
\end{center}
\end{table}

\subsection{XMSS Key Generation}
For a depiction of the XMSS tree referenced in this section, see Figure~\ref{img:xmss_complete_tree_example}. 
Like in MSS (see Section~\ref{cha:mss_keygen}), the signer chooses the parameters for the tree as well as for the corresponding one-time signature scheme W-OTS+.

% insert what to do for W-OTS+/ W-OTS+ param here
The W-OTS+ private keys $(X_0, \cdots, X_{2^d-1})$, ($d$ denotes the height of the complete XMSS tree - better: $d + l = $ ´height of whole merkle tree), are generated using a cryptographic pseudorandom method $PRF$, to generate the XMSS private key from a single $n$-byte value. 
% pseudorand. function
\begin{equation}
PRF: {} \rightarrow {}
\end{equation}

% ------------ random stuff about PRF
The bitmasks are generated from a public seed that is part of the public key using the pseudorandom function $PRF$:

To generate randomness, a pseudo-random function $h_{prf}$/$PRF$/$f_{rand}$ is used. It takes a seed $sd$ as input, and generates a random output. % deterministischer output?
% Parameters XMSS/WOTS+ - PRF erklären
% -> nur 1 seed gespeichert, aus dem Zufall erzeugt wird, aus dem private keys erzeugt werden + bitmasks!

% For each call of the hash function, a new bitmask is used.
Given two hash functions.. % siehe Fabios Paper zum weitermachen
The hash function $h_{rand}$ takes one bitmask $b_{i,j}$ as random input. % not so true... first hash function generates input? continue reading paper

% collission resistance at hash function not necessary -> use bitmasks for that

% --------- END random stuff for PRF 

A uniformly random n-byte string S is sampled from a secure source of randomness. This string S is stored as private key.
The seed S MUST be independent of SEED (pubkey seed, used to randomize hash function calls), and because it is the main secret, it MUST be kept secret. This seed S is used to generate an n-byte value $S_{ots}$ for each WOTS+ key pair.

The advantage of generating the private key elements from a random n-byte string is that only this n-byte string needs to be stored instead of the full private key. The key can be regenerated when needed.

% xmss priv key
The XMSS private key $X_{XMSS}$ consists of $2^d$ W-OTS+ one-time private keys, the leaf index $s_{next}$ of the next unused private one-time key, and a private seed $X_{PRF}$ to generate pseudo-random values for randomized message hashing.
% ToDO: include n-byte..etc, how much byte each param. has
% "Theoretically" also part of priv. key: .. the n-byte value root (which is the root node of the tree and SEED), and the n-byte public seed used to pseudorandomly generate bitmasks and hash function keys. Although root and SEED formally would be considered only part of the public key, they are needed (e.g., for signature generation) and hence are also required for functions that do not take the public key as input.
\begin{equation}
\label{eq:priv_key}
X = ((X_0, \cdots, X_{2^d-1}), s_{next}, X_{PRF})
\end{equation}
The leaf index $s_{next}$ is initialized to zero when the XMSS private key is created. The key $X_{PRF}$ must be sampled from a secure source of randomness that follows the uniform distribution.  


% draft
% xmss public key
The public key of XMSS $Y_{XMSS}$ consists of the root of the XMSS tree and the public seed used for construction of the bitmasks.
% ! mark root of xmss tree also as H_{d,0}?
\begin{equation}
\label{eq:xmss_pubkey}
Y_{XMSS} = (H_{d,0}, \text{seed})
\end{equation}

% source https://eprint.iacr.org/2011/484.pdf angeben / oder zu allgemein und nicht nötig?
\begin{equation}
\label{eq:xmss_bitmasks}
H_{i,j} =  h(H_{i-1,2j} \oplus b_{i,left} \concat H_{i-1,2j+1} \oplus b_{i,right})
\end{equation}

% explain bitmasks on xmss with little tree image:
\begin{figure}
\centering
\begin{tikzpicture}[edge from parent fork down]
\node(root){$H_{i,j}$}
	child{node[rectangle, draw](root2){Hashfunction $h$} edge from parent [<-]
		child {node(a)[circle, draw] {\tiny XOR} edge from parent [<-]
			child {node(c) {$H_{i-1,2j}$}}
		}
		child{node(b)[circle, draw] {\tiny XOR} edge from parent [<-]
			child{node(d) {$H_{i-1,2j+1}$}}	
		}
	};
	
% left bitmask	
\node[left=1 of a] (la) {$b_{i,left}$}; 

% right bitmask
\node[right=1 of b] (rb) {$b_{i,right}$};

% arrow from left bitmask to left XOR
\draw[<-] %line from la (left bitmask) -> left XOR
    ($(a.west)$) -- (la);	

% arrow from right bitmask to right XOR
\draw[<-] %line from rb (right bitmask) -> right XOR
    ($(b.east)$) -- (rb);	

\end{tikzpicture}
\caption{An example parent node $H_{i,j}$ with the corresponding children $H_{i-1,2j},H_{i-1,2j+1}$ of a XMSS tree. The node $H_{i,j}$ is calculated by adding two bitmasks $b_{i,left}, b_{i,right}$ to its children. The result is concatenated and used as input for the hashfunction~$h$ (see Equation~\ref{eq:xmss_bitmasks}).}
\label{img:example_xmss_minitree}
\end{figure}

% explain bitmasks on WOTS = WOTS+
\begin{figure}
\centering
\begin{tikzpicture}[edge from parent fork down]
\node[]{parent wots chain}
	child{node[rectangle, draw]{Hashfunction $h$} edge from parent[<-]
		child{node[circle,draw] (xor) {\tiny XOR} edge from parent[<-]
			child{node[]{child wots chain}
			}
		}
	};
	
% right bitmask
% !! index b_i,j -> explain/check indizes
\node[right=1 of xor] (rb) {$b_{i,j}$};

% arrow from right bitmask to right XOR
\draw[<-] %line from rb (right bitmask) -> right XOR
    ($(xor.east)$) -- (rb);

\end{tikzpicture}
\caption{An example for on W-OTS+ chain, including the bitmask $b_{i,j}$.}
\label{img:example_wots+_bitmask}
\end{figure}


\subsection{XMSS Signature Generation}
% Quelle: RFC xmss
% idx = index of next unused WOTS keypair/leaf
% A_s = authpath, außerdem: bytestring r für randomized message hashing -> wirklich hier nötig?

\begin{equation}
\label{eq:xmss_sign}
\sigma_{XMSS} = (idx, \sigma_{OTS}, A_s, ...) 
\end{equation}


% complete xmss example graph
\begin{figure}
\centering 
\begin{tikzpicture}
[	
	level 1/.style = {sibling distance = 8cm},
	level 2/.style = {sibling distance = 4cm},
	level 3/.style = {sibling distance = 2cm},
    level 4/.style = {sibling distance = 1cm},
    level 5/.style = {sibling distance = 0.5cm},
    level 6/.style = {circle,draw,fill=cyan_tud}
    % edge from parent fork down -> would be forked tree style
]
% Merkle Tree
\node(root)[]{public key}
	child{node[circle, draw]{}
		child{node[circle, draw]{}
			child{node(left_lowest_merkle)[circle, draw]{}
				child{node[circle, draw]{}
					child{node[circle, draw, fill=darkblue_tud]{}
						child{node[circle,fill=cyan_tud]{} edge from parent[<-, dashed]}					
					}
					child{node[circle, draw, fill=darkblue_tud]{}
						child{node[circle,fill=cyan_tud]{} edge from parent[<-, dashed]}
					}					
				}
				child{node[circle, draw]{}
					child{node[circle, draw, fill=darkblue_tud]{}
						child{node[circle,fill=cyan_tud]{} edge from parent[<-, dashed]}					
					}
					child{node[circle, draw, fill=darkblue_tud]{}
						child{node[circle,fill=cyan_tud]{} edge from parent[<-, dashed]}					
					}					
				}		
			}
			child{node[circle, draw]{}
				child{node[circle, draw]{}
					child{node[circle, draw, fill=darkblue_tud]{}
						child{node[circle,fill=cyan_tud]{} edge from parent[<-, dashed]}					
					}
					child{node[circle, draw, fill=darkblue_tud]{}
						child{node[circle,fill=cyan_tud]{} edge from parent[<-, dashed]}					
					}					
				}
				child{node[circle, draw]{}
					child{node[circle, draw, fill=darkblue_tud]{}
						child{node[circle,fill=cyan_tud]{} edge from parent[<-, dashed]}					
					}
					child{node[circle, draw, fill=darkblue_tud]{}
						child{node[circle,fill=cyan_tud]{} edge from parent[<-, dashed]}					
					}						
				}				
			}		
		}
		child{node[circle, draw]{}
			child{node[circle, draw]{}
				child{node[circle, draw]{}
					child{node[circle, draw, fill=darkblue_tud]{}
						child{node[circle,fill=cyan_tud]{} edge from parent[<-, dashed]}					
					}
					child{node[circle, draw, fill=darkblue_tud]{}
						child{node[circle,fill=cyan_tud]{} edge from parent[<-, dashed]}					
					}						
				}
				child{node[circle, draw]{}
					child{node[circle, draw, fill=darkblue_tud]{}
						child{node[circle,fill=cyan_tud]{} edge from parent[<-, dashed]}					
					}
					child{node[circle, draw, fill=darkblue_tud]{}
						child{node[circle,fill=cyan_tud]{} edge from parent[<-, dashed]}					
					}						
				}				
			}
			child{node[circle, draw]{}
				child{node[circle, draw]{}
					child{node[circle, draw, fill=darkblue_tud]{}
						child{node[circle,fill=cyan_tud]{} edge from parent[<-, dashed]}					
					}
					child{node[circle, draw, fill=darkblue_tud]{}
						child{node[circle,fill=cyan_tud]{} edge from parent[<-, dashed]}					
					}						
				}
				child{node[circle, draw]{}
					child{node[circle, draw, fill=darkblue_tud]{}
						child{node[circle,fill=cyan_tud]{} edge from parent[<-, dashed]}					
					}
					child{node[circle, draw, fill=darkblue_tud]{}
						child{node[circle,fill=cyan_tud]{} edge from parent[<-, dashed]}					
					}						
				}				
			}		
		}
	}
	child{node[circle, draw]{}
		child{node[circle, draw]{}
			child{node[circle, draw]{}
				child{node[circle, draw]{}
					child{node[circle, draw, fill=darkblue_tud]{}
						child{node[circle,fill=cyan_tud]{} edge from parent[<-, dashed]}					
					}
					child{node[circle, draw, fill=darkblue_tud]{}
						child{node[circle,fill=cyan_tud]{} edge from parent[<-, dashed]}					
					}						
				}
				child{node[circle, draw]{}				
					child{node[circle, draw, fill=darkblue_tud]{}
						child{node[circle,fill=cyan_tud]{} edge from parent[<-, dashed]}					
					}
					child{node[circle, draw, fill=darkblue_tud]{}
						child{node[circle,fill=cyan_tud]{} edge from parent[<-, dashed]}					
					}		
				}
			}
			child{node[circle, draw]{}
				child{node[circle, draw]{}
					child{node[circle, draw, fill=darkblue_tud]{}
						child{node[circle,fill=cyan_tud]{} edge from parent[<-, dashed]}					
					}
					child{node[circle, draw, fill=darkblue_tud]{}
						child{node[circle,fill=cyan_tud]{} edge from parent[<-, dashed]}					
					}										
				}
				child{node[circle, draw]{}	
					child{node[circle, draw, fill=darkblue_tud]{}
						child{node[circle,fill=cyan_tud]{} edge from parent[<-, dashed]}					
					}
					child{node[circle, draw, fill=darkblue_tud]{}
						child{node[circle,fill=cyan_tud]{} edge from parent[<-, dashed]}					
					}					
				}				
			}		
		}
		child{node[circle, draw]{}
			child{node[circle, draw]{}
				child{node[circle, draw]{}
					child{node[circle, draw, fill=darkblue_tud]{}
						child{node[circle,fill=cyan_tud]{} edge from parent[<-, dashed]}					
					}
					child{node[circle, draw, fill=darkblue_tud]{}
						child{node[circle,fill=cyan_tud]{} edge from parent[<-, dashed]}					
					}						
				}
				child{node[circle, draw]{}
					child{node[circle, draw, fill=darkblue_tud]{}
						child{node[circle,fill=cyan_tud]{} edge from parent[<-, dashed]}					
					}
					child{node[circle, draw, fill=darkblue_tud]{}
						child{node[circle,fill=cyan_tud]{} edge from parent[<-, dashed]}					
					}						
				}				
			}
			child{node(lowest_rightest_merkle)[circle, draw]{}
				child{node[circle, draw]{}
					child{node[circle, draw, fill=darkblue_tud]{}
						child{node[circle,fill=cyan_tud]{} edge from parent[<-, dashed]}					
					}
					child{node[circle, draw, fill=darkblue_tud]{}
						child{node[circle,fill=cyan_tud]{} edge from parent[<-, dashed]}					
					}						
				}
				child{node[circle, draw]{}
					child{node[circle, draw, fill=darkblue_tud]{}
						child{node[circle,fill=cyan_tud]{} edge from parent[<-, dashed]}					
					}
					child{node[circle, draw, fill=darkblue_tud]{}
						child{node[circle,fill=cyan_tud]{} edge from parent[<-, dashed]}					
					}					
				}				
			}		
		}
	};
	
\coordinate (m_bracket_south) at ($(lowest_rightest_merkle.south east)+(1,0)$);

% right side: arrow+label
\draw[decorate,decoration={brace,mirror,amplitude=3mm}] 
% near start: place Label1 low, fill=white: break arrow-line for label in line
(m_bracket_south) -- (m_bracket_south|-root.east) node [pos=0.5,right=0.3] {$d$};

\draw[thick]
($(left_lowest_merkle.south west)-(0,0.2)$) -- ($(m_bracket_south)-(0,0.2)$);
\end{tikzpicture}
\caption{This is an complete XMSS tree with the parameters $d=3$ (height of the Merkle tree). The amount of Winternitz one-time keys for one Merkle node / amount of leaves for one L-Tree is $l=4$.}
\label{img:xmss_complete_tree_example}
\end{figure}


% -------- EXAMPLE GRAPH -------------------
%\begin{figure}
%\centering
%\begin{tikzpicture}[
%    level/.style={sibling distance=40mm/#1}
%    ]
%
%\node (z){z} 
%  child {node (a) {node1}
%    child {node  (b) {node3}
%      child {node (b1) {$\vdots$} 
%       child {node (b11) {b11}}
%      }
%      child {node (b2) {$\vdots$} 
%       child {node (b12) {leaf1}}
%      }
%    }
%    child {node (g) {node4}
%      child {node (g1) {$\vdots$}
%       child {node (g11) {...}}
%      }
%      child {node (g2) {$\vdots$} 
%       child {node (g12) {g12}}
%      }
%    }
%  }
%    child {node (d) {node2}
%      child {node  (e) {node5}
%        child {node (e1) {$\vdots$} 
%         child {node (e11) {e11}}
%        }
%        child {node (e2) {$\vdots$} 
%         child {node (e12) {...}}
%        }
%      }
%      child {node (f) {node6}
%        child {node (f1) {$\vdots$} 
%         child {node (f11) {...}}
%        }
%        child {node (f2) {$\vdots$} 
%         child {node (f12) {f12}
%         }
%         }
%  }
%};
%
%% cn's on left side of tree
%\node[left=5 of z] (ln1) {level0} 
%    child {node (ln2) {level1} edge from parent [draw=none]
%        child {node (ln3) {level2} edge from parent [draw=none]
%            child {node (ln4) {} edge from parent [draw=none]
%                child {node (ln5) {level leaves} edge from parent [draw=none] }}}}; 
%
%% punkte zw leaves
%%\path (b12.north east) -- (g11.north west) node [midway] {$\cdots$};
%%\path (e12.north east) -- (f11.north west) node [midway] {$\cdots$};
%
%\coordinate (cd1) at ($(f12)+(1,0)$);
%\coordinate (nb1) at ($(g12)!.5!(e11)$);
%
%% RECHTE Seite Pfeil+Label1
%\draw[thick,<->,] 
%% near start: platziert Label1 unten, fill=white: Linie wird unterbrochen für Label1
%    (cd1) -- (cd1|-z.east) node [near start, fill=white] {Label1};
%
%\draw[dashed,thick] % dotted line from cn (root) --> cn (left side)
%    ($(z.west)+(-1em,0)$) -- (ln1);
%\draw[dashed,thick,->] % % blue dotted line from cn/2 --> cn (left
%    ($(a.west)+(-1em,0)$) -- (ln2.east);
%%\draw[blue!70!black,dashed,thick,->]    
%%    ($(b.west)+(-1em,0)$) -- (ln3);
%%\draw[blue!70!black,dashed,thick,->]    
%%    ($(b11.west)+(-1em,0)$) -- (ln5);
%
%\draw[thick,decorate,decoration={brace,amplitude=10pt,mirror},-,-{latex[flex=1pt]}] (b11.south west) -- (f12.south east); % curly bracket at leaves!
%
%\end{tikzpicture}
%\caption{This is an example tree.}
%\label{img:example_tree}
%\end{figure}
% ---------------- END EXAMPLE GRAPH ---------------------------


\subsection{XMSS Signature Verification}

% Additional XMSS stuff:
% For further details on the security model of XMSS, we refer to [21] and for further security notions for the defined constructions, we refer to [5].-> fabios paper
% Explain difference: LMS vs XMSS (coll.res of hashfct not necessary)
% XMSS^MT: a multi-tree variant of XMSS -> maybe explain here

% ganz am Ende: Übersichtstabelle zu allen Zeit/Speicheraufwandszeiten
% MSS key pair generation requires the computation of 2^d one-time key pairs and 2^(d+1)-1 evaluations of the hash function.
% WOTS keygen+sign+verify time / aufwand / speicherverbrauch -> Positiv: Wenig Speicherverbrauch, kleinere Signatur als bei Lamport-Diffie!

% Facts Merkle-Tree:
% - Each public key (== root of the tree) can only be used to sign fixed number of messages - typically 2^n (weil 2^d = #Blätter von Baum mit Höhe d)
% + public key: short, only one hash value
% - signature size: huge, contains d public keys (für jede Höhe des Baumes eine, ein a_i + die one-time signatur an sich)
% - Berechnung public key (root): berechnen + speichern von 2^n ots-keys -> vlt kürzer mit treehash algo
% -> tradeoff zw. speicher+zeit: private keys S_i, deterministisch von kurzem secret seed S. Wenig Speicher für seed benötigt, dafür Zeit für Berechnung von secret keys->signature generation benötigt

	