\chapter{Background}
\label{cha:background}
This chapter addresses the scientific background needed for this work. First, the general concept digital signature systems and hash functions are elaborated. Afterwards, the most common concepts for post-quantum digital signature systems are explained. 

\section{Digital Signature Schemes}
% ! digital signature scheme -> assymetrisch (immer?) 
A \textit{digital signature scheme} uses a set of rules and a set of parameters to verify the identity of the originator and integrity of data.~\cite{cha:bg_digital_sign_schemes_NIST_standard1992} 

In this section, for explanatory reasons, data refers to a message being sent from one sender to a recipient across a network (i.e. LAN). The sender is the person signing the message, the recipient usually wants to verify the received message, therefore they are also referred to as signer and verifier. % 3. unabhängige Person auch als verifier?
The \textit{digital signature~$\sigma$} of a message, generated by a digital signature scheme, is a value dependent on some secret known only to the signer (usually the private key~$X$) and on the content of the message being signed. With the corresponding public key~$Y$ (without having access to the signer's private key $X$) the authenticity of the signature can be verified, either by the recipient directly or a third party : It is ensured that the message actually belongs to the signer - a lying signer trying to repudiate their signature, a fraudulent claimant arguing the message is theirs, or a message that has been tempered with can be detected.
% hier vlt Bild von Signatursystem?
% hier schutzziele erwähnen (vlt Liste?) -> recipient will bestätigung das nachricht wirklich vom empfänger, sender will dass recipient ihm keine falschen nachrichten unterschiebt
To ensure the above mentioned properties of digital signatures, a digital signature scheme consists of the following parts (see also figure~\ref{img:digital_sign_system_simple}):~\cite{cha:bg_signature_schemes_book_menezes2018_1997} % gehört keygen wirklich zu signatursystem? -> ganze section beruht auf diesem Buch, wird das klar?

\begin{figure}
\centering
\includegraphics[width=\linewidth]{images/Background/Digital_Signaturesystem_Simple.png}
\caption{The general structure of a digital signature system. The key generation algorithm creates the private key~$X$ and public key~$Y$, whereas $X$ is only known to the signer and $Y$ is made public for the verifier. The signer creates the message $M$ and signs it with the private key, using the signature generation algorithm. Afterwards, the so generated signature~$\sigma$ and the corresponding message~$M$ are sent to the verifier. The verifier checks the validity of the message and the corresponding signature with the public key (that is already known after key generation and distribution)and the verification algorithm. If the verification algorithm evaluates returns a valid result, the verifier can trust the message or otherwise knows it has been tempered with}
\label{img:digital_sign_system_simple}
\end{figure} 

\begin{enumerate}
\item The \textit{key generation algorithm} creates a private key $X$ known only to the sender used for signature generation, and a public key $Y$ used by the recipient for signature verification. Both keys are mathematically dependent from each other, in which way is determined by the specific type of signature scheme (i.e. the Winternitz signature scheme, see section~\ref{sec:WOTS_keygen}). % und auch noch von weiteren Leuten die Originalität von Nachricht prüfen wollen? Aber in meinem runtergebrochenen Beispiel nur 2 Leute, außerdem wird nicht erklärt dass auch key signiert wird
\item The \textit{signature generation algorithm} creates the digital signature~$\sigma$ of a message with the private key $X$ of the signer and the content of the message.
\item The \textit{verification algorithm} is used by the recipient or a third party to verify the authenticity of the signature~$\sigma$ and the corresponding message with the public key $Y$.
\end{enumerate}
% Y muss vor signieren der Nachricht veröffentlich werden

% Bild / Schema einfügen

% es wird message digest signiert
% Überleitung zu Hashfunctions

\section{Definition of Hashfunctions}
% preimage resistance, second preimage resistance, collission resistance -> hier erklären 
The security of One-Time Signature Schemes is based on cryptographic secure hash functions. A hash function is a function that can be computed efficiently and maps strings of arbitrary length to strings of fixed length~\cite{cha:bg_hashfunctions_thesis_matusiewicz2007}. Therefore a hash function $h$ is defined as any function $h: X \rightarrow Y$, where $X$ and $Y$ are
finite sets with $|X| = X_{len}$ (arbitrary length) and $|Y| = Y_{len}$ (fixed length)~\cite{cha:bg_hashfunctoins_Stinson2006}. A hash function is considered \textit{cryptographically secure} if it has the following  properties:~\cite{cha:bg_hashfunctions_BASIC_DEFINITIONS_Springer2004} 

% M ist auch die ungehashte message später -> dort umbenennen zB M_sent \\ hashfunction hat fixe outputlänge? also M fix?
\begin{enumerate} % fotos einfügen?
	\item \textbf{Preimage-Resistance / One-wayness}
	 A hash function $h$ is preimage-resistant if given the output value of the function, it is computationally infeasible to find any input which generates this output, i.e. finding any preimage $x$ such that $h(x) = y $ when given any $y$, but the corresponding input for $h$ that generated $y$ is not known.

\begin{minipage}[t]{.5\linewidth}
          	\raggedright
            \includegraphics[width=.8\linewidth]{images/Background/preimage_res_horizontal.png}
	      \end{minipage} 

	\item \textbf{Second Preimage-Resistance}
	A hash function $h$ is second preimage-resistant, if given any input value and the corresponding output, it is computationally infeasible to find another distinct
input that produces the same output, i.e. given any $x$ finding a second preimage $x \neq x'$ such that $h(x) = h(x')$. % oder erst formel -> dann beschreibung dran?

\begin{minipage}[t]{.6\linewidth}
          	\raggedright
            \includegraphics[width=.8\linewidth]{images/Background/second_preimage_res_horizontal.png}
	      \end{minipage} 
	
	\item \textbf{Collision Resistance}
	A hash function $h$ is called collision-resistant, if it is computationally infeasible to find a pair of different inputs $x, x'$ that map to the same output value, such that $h(x) = h(x')$.


\begin{minipage}[t]{.6\linewidth}
          	\raggedright
            \includegraphics[width=.8\linewidth]{images/Background/collission_res_horizontal.png}
	      \end{minipage}
	      
\end{enumerate}	      

% ONE-Time Signature scheme anmerken / erklären

\section{One-Time Signature Schemes}
This section is mainly based on the work of Buchmann et al~\cite{book_pqc_bernstein_2004}. The following types of functions are used for the Lamport-Diffie One-Time Signature Scheme and the Winternitz One-Time Signature Scheme. 
The cryptographic hash function~$h$ is preimage resistant, second preimage-resistant and collision resistant, it is applied to the original message and generates the message digest.
The one-way function~$f$ is a hash function that is at least preimage-resistant and takes a fixed input length, because it is applied to the message digest.% später wird Benutzung von h und f noch sichtbar
% hier erklären was one time signature scheme ist & dass LD-OTS und Winternitz-OTS erklärt werden

\begin{equation}
\label{eq:basic_hashfunc}
\textbf{Cryptographic hash function h: } \lbrace 0,1 \rbrace^* \rightarrow \lbrace 0,1 \rbrace^n
\end{equation}

\begin{equation}
\label{eq:one-way-func}
\textbf{One-way function f: } \lbrace 0,1 \rbrace^n \rightarrow \lbrace 0,1 \rbrace ^n
\end{equation}


\subsection{Lamport-Diffie One-Time Signature Scheme}
The Lamport–Diffie one-time signature scheme (LD-OTS) was first proposed by Leslie Lamport in 1979~\cite{lamport_signature_scheme_1979}. 
It is a signature scheme where the public key can only be used to sign a single message.
%-> bei allen OTS schemes so, vlt vorher erklären / zusammenfassen?


\subsubsection{LD-OTS Key Generation}
The private key X consists of $2n$ bit strings, each of length $n$, chosen at random. % n ist security parameter

\begin{equation}
\label{eq:ldots_sign_key}
X = \left(x_{0}\left[0\right], x_{0}\left[1\right], x_{1}\left[0\right], x_{1}\left[1\right], \cdots, x_{n-1}\left[0\right], x_{n-1}\left[1\right] \right)
\end{equation}
The public key $Y$ is created out of the signature key $X$. For each $x_i[j] \in X, 0 \leq i \leq n-1, j \in \lbrace 0,1 \rbrace$, the one-way function~f (see equation~\ref{eq:one-way-func}) is applied.

\begin{equation}
y_i[j] \in Y = f(x_i[j]), 0 \leq i \leq n-1, j \in \lbrace 0,1 \rbrace
\end{equation}

\begin{equation}
Y = \left( 
y_{0}\left[0\right], y_{0}\left[1 \right], y_{1}\left[0\right], y_{1}\left[1\right], \cdots, y_{n-1}\left[0\right], y_{n-1}\left[1\right]
\right)
\end{equation}

\subsubsection{LD-OTS Signature Generation} % m has fixed length
Before signing, the public key $Y$ has to be published.
The private key $X$ (see equation~\ref{eq:ldots_sign_key}) is used to sign the message $M \in \lbrace 0,1 \rbrace^*$. 
The cryptographic hash function $h$ (see equation~\ref{eq:basic_hashfunc}) is applied to $M$ in order to get the hash digest $m$ of fixed length $n$.

\begin{equation}
\label{eq:hash_message}
m = h(M) = (h_{0}, \cdots, h_{n-1})
\end{equation} % Elemente von m ENTWEDER m_i ODER h_i
For each $h_i \in m$, the corresponding $x_i[h_i]$ out of private key $X$ is chosen, resulting in signature $\sigma$ for message $m$.
% h_i in m_i umbenennen oder umgekehrt -> konsequent bleiben
\begin{equation}
\sigma = \left(
x_0 \left[ h_0 \right], x_1\left[ h_1 \right], \cdots, x_{n-1}\left[ h_{n-1}\right]
\right) = (\sigma_0, \cdots, \sigma_{n-1})
\end{equation}

\subsubsection{LD-OTS Verification}
After receiving a message $M$ with the corresponding signature $\sigma$, the verifier calculates the message digest $h(M) = m$. 
To verify the given signature $\sigma$, it is necessary to check the following condition.
\begin{equation}
\left(
f(\sigma_0), \cdots, f(\sigma_{n-1})
\right) =
\left(
y_0[h_0], \cdots, y_{n-1}[h_{n-1}]
\right)
\end{equation}
If the condition is true, the signature is valid.

% nochmal extra auf Einmalverwendung hinweisen
% table with properties i.e.
% keygen+sign+verify time / aufwand / speicherverbrauch -> Positiv: schnelle signatur+keygen Negativ: Viel Speicherverbrauch
% Überleitung zu Winternitz weil diese Vorteil kürzerer Signatur aufweisen

\subsection{Winternitz One-Time Signature Scheme}
LD-OTS signatures are efficient to calculate but have a huge size and therefore need a lot of memory. The Winternitz one-time signature scheme (W-OTS) generates signatures with substantially shorter size. W-OTS uses the same hash function (equation~\ref{eq:basic_hashfunc} and one-way function (equation~\ref{eq:one-way-func}) as LD-OTS. %genauer beschreiben evtl

\subsubsection{W-OTS Key Generation}
\label{sec:WOTS_keygen}
First, two parameters are selected: The Winternitz-Parameter $w \geq 2$ and the security parameter $n$. When increasing $w$, the signature size will decrease linearly and the effort for key generation, signing and verification will increase exponentially. As $n$ is the length of the message digest, increasing it leads to higher security because it increases the collision resistance of the hash function. % weil mehr Winternitz-Ketten generiert werden, je kleiner w ist, reduziert ein hohes w die Signaturgröße
% The Winternitz parameter w enables space/time trade-offs.

% bezieht sich auf #stücke in die m geteilt wird
\begin{equation}
\label{eq:t1}
t_1 = \ceil[\Bigg]{\frac{n}{w}}
\end{equation}

% bezieht sich auf #stücke in die checksum geteilt wird
\begin{equation}
\label{eq:t2}
t_2 = \ceil*{\frac{\floor*{\log_2 t_1} + 1 + w}{w} }
\end{equation}

% anzahl stücke von signatur M || C am ende
\begin{equation}
\label{eq:t}
t = t_1 + t_2
\end{equation}
The private key $X$ consists of $t$ bit strings, each of length $n$ chosen at random.

\begin{equation}
\label{eq:wots_privkey}
X = (x_0, \cdots, x_{t-1})
\end{equation}
The public key $Y$ is generated by applying the one-way function~$f$ to each element $x_i  \in X$  consecutively $2^w - 1$ times. % hier sieht man dass höheres w -> höherer Aufwand Keygen

\begin{equation}
y_i \in Y =  f^{2^w-1}(x_i), 0 \leq i \leq t-1 
\end{equation}

\begin{equation}
Y = (y_0, \cdots, y_{t-1})
\end{equation}
Each $y_i \in Y$ is a bit string of length $n$. The public key $Y$ has to be published before the signature can be generated.

\subsubsection{W-OTS Signature Generation}
For signing a message $M \in \lbrace 0,1 \rbrace^*$, the cryptographic hash function~h (see equation~\ref{eq:basic_hashfunc}) is applied to $M$ (see equation~\ref{eq:hash_message}). The resulting hash digest $m$ is split into $t_1$ bitstrings of length $w$. If $m$ is not divisible by $w$, it is necessary to add leading zeros to $m$ before splitting.

\begin{equation}
\label{eq:hash_digest_split}
m = m_0 | m_1 | \cdots | m_{t_1-1}
\end{equation}
Each bitstring $m_i \in m$ is converted to its decimal representation in order to calculate the checksum $c$.
% checksum t2 Teile der Länge w teilbar

\begin{equation}
\label{eq:checksum_calculation}
c = \sum_{i = 0}^{t-1}(2^w-m_i)
\end{equation}
The checksum $c$ is divided into $t_2$ bitstrings of length $w$. In order to divide $c$ this way, it can be necessary to add leading zeros to $c$ as a padding.
\begin{equation}
c = c_0 | c_1 | \cdots | c_{t_2 - 1}
\end{equation}
Afterwards, $m$ and $c$ are concatenated to one block~$B$. This leads to $t$ bitstrings of length $w$ in total, as $t = t_1 + t_2$.

\begin{align}
\label{eq:block_B_out_of_M_and_C}
B &= m | c  \\ 
&= m_0 | \cdots | m_{t_1 - 1} | c_0 | \cdots | c_{t_2 - 1} \nonumber \\
&= b_0 | \cdots | b_{t-1} \nonumber
\end{align}
The signature $\sigma$ is calculated by applying the one-way function~$f$ to each part of the private key $X$ (see equation~\ref{eq:wots_privkey}) several times: The element $b_i \in B$ determines the amount of times the hash function $f$ is applied to the corresponding $x_i \in X$.

\begin{equation}
\sigma = f^{b_0}(x_0), f^{b_1}(x_1), \cdots, f^{b_{t-1}}(x_{t-1}) = (\sigma_0, \cdots, \sigma_{t-1})
\end{equation}

\subsubsection{W-OTS Verification}
Given a signature $\sigma$ and message $M$, the hash digest $m$ is generated (see equation~\ref{eq:hash_message}). Afterwards, the block $B$ is generated out of~$m$ as shown in the previous section (see equations~\ref{eq:hash_digest_split} to~\ref{eq:block_B_out_of_M_and_C}). To check if the given signature is valid, the one-way function~$f$ is applied $2^w - 1 - b_i$ times to each $\sigma_i \in \sigma$. The result is compared to the corresponding $y_i \in Y$.

\begin{equation}
(f^{(2^w-1)-b_0}(\sigma_0), \cdots, f^{(2^w - 1) - b_{t-1}}(\sigma_{t-1})) \? (y_0, \cdots, y_{t-1})
\end{equation}
If each $f^{2^w-1-b_i}(\sigma_i) = y_i$, the signature is valid because $\sigma_i = f^{b_i}(x_i)$ and therefore

\begin{gather}
f^{2^w-1-b_i}(\sigma_i) = f^{2^w-1}(x_i) = y_i \\
\forall 0 \leq i \leq t-1 \nonumber
\end{gather}

% dann überleiten -> merkle trees, diese benutzen um OTS zu "Mehrmaligen" Signatursystemen zu machen 

% keygen+sign+verify time / aufwand / speicherverbrauch -> Positiv: Wenig Speicherverbrauch, kleinere Signatur als bei Lamport-Diffie!

\section{Merkle-Trees}
