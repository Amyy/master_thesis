\chapter{Background}
\label{cha:background}

% allgemein Signatursysteme: was machen sie, für was braucht man sie
% es wird message digest signiert

\section{Hashfunctions}
% preimage resistance, second preimage resistance, collission resistance -> hier erklären

\section{One-Time Signature Schemes}
This section is mainly based on the work of Buchmann et al~\cite{book_pqc_bernstein_2004}.
% hier erklären was one time signature scheme ist & dass LD-OTS und Winternitz-OTS erklärt werden
% dann überleiten -> merkle trees, diese benutzen um OTS zu "Mehrmaligen" Signatursystemen zu machen 
% hashfunctions vorher erklären? also bei OTS und dann hier nur darauf referenzieren



% werden bei LD + Winternitz so benutzt
\begin{equation}
\label{eq:one-way-func}
\textbf{One-way function f: } \lbrace 0,1 \rbrace^n \rightarrow \lbrace 0,1 \rbrace ^n
\end{equation}

\begin{equation}
\label{eq:basic_hashfunc}
\textbf{Cryptographic hash function h: } \lbrace 0,1 \rbrace^* \rightarrow \lbrace 0,1 \rbrace^n
\end{equation}

\subsection{Lamport-Diffie One-Time Signature Scheme}
The Lamport–Diffie one-time signature scheme (LD-OTS) was first proposed by Leslie Lamport in 1979~\cite{lamport_signature_scheme_1979}. 
It is a signature scheme where the public key can only be used to sign a single message.
%-> bei allen OTS schemes so, vlt vorher erklären / zusammenfassen?


\subsubsection{LD-OTS Key Generation}
The private key X consists of $2n$ bit strings, each of length $n$, chosen at random. % n ist security parameter

\begin{equation}
\label{eq:ldots_sign_key}
X = \left(x_{0}\left[0\right], x_{0}\left[1\right], x_{1}\left[0\right], x_{1}\left[1\right], \cdots, x_{n-1}\left[0\right], x_{n-1}\left[1\right] \right)
\end{equation}
The public key $Y$ is created out of the signature key $X$. For each $x_i[j] \in X, 0 \leq i \leq n-1, j \in \lbrace 0,1 \rbrace$, the one-way function~f (see equation~\ref{eq:one-way-func}) is applied.

\begin{equation}
y_i[j] \in Y = f(x_i[j]), 0 \leq i \leq n-1, j \in \lbrace 0,1 \rbrace
\end{equation}

\begin{equation}
Y = \left( 
y_{0}\left[0\right], y_{0}\left[1 \right], y_{1}\left[0\right], y_{1}\left[1\right], \cdots, y_{n-1}\left[0\right], y_{n-1}\left[1\right]
\right)
\end{equation}

\subsubsection{LD-OTS Signature Generation} % m has fixed length
Before signing, the public key $Y$ has to be published.
The private key X (see equation~\ref{eq:ldots_sign_key}) is used to sign the message $M \in \lbrace 0,1 \rbrace^*$. 
The cryptographic hash function $h$ (see equation~\ref{eq:basic_hashfunc}) is applied to $M$ in order to get the hash digest $m$ of fixed length $n$.

\begin{equation}
\label{eq:hash_message}
m = h(M) = (h_{0}, \cdots, h_{n-1})
\end{equation}
For each $h_i \in m$, the corresponding $x_i[h_i]$ out of private key $X$ is chosen, resulting in signature $\sigma$ for message $m$.
% h_i in m_i umbenennen oder umgekehrt -> konsequent bleiben
\begin{equation}
\sigma = \left(
x_0 \left[ h_0 \right], x_1\left[ h_1 \right], \cdots, x_{n-1}\left[ h_{n-1}\right]
\right) = (\sigma_0, \cdots, \sigma_{n-1})
\end{equation}

\subsubsection{LD-OTS Verification}
After receiving a message $M$ with the corresponding signature $\sigma$, the verifier calculates the message digest $h(M) = m$. 
To verify the given signature $\sigma$, it is necessary to check the following condition.
\begin{equation}
\left(
f(\sigma_0), \cdots, f(\sigma_{n-1})
\right) =
\left(
y_0[h_0], \cdots, y_{n-1}[h_{n-1}]
\right)
\end{equation}
If the condition is true, the signature is valid.

% nochmal extra auf Einmalverwendung hinweisen
% table with properties i.e.
% keygen+sign+verify time / aufwand / speicherverbrauch -> Positiv: schnelle signatur+keygen Negativ: Viel Speicherverbrauch
% Überleitung zu Winternitz weil diese Vorteil kürzerer Signatur aufweisen

\subsection{Winternitz One-Time Signature Scheme}
LD-OTS signatures are efficient to calculate but have a huge size and therefore need a lot of memory. The Winternitz one-time signature scheme (W-OTS) generates signatures with substantially shorter size. W-OTS uses the same hash function (equation~\ref{eq:basic_hashfunc} and one-way function (equation~\ref{eq:one-way-func}) as LD-OTS. %genauer beschreiben evtl

\subsubsection{W-OTS Key Generation}
First, two parameters are selected: The Winternitz-Parameter $w \geq 2$ and the security parameter $n$. When increasing $w$, the signature size will decrease linearly and the effort for key generation, signing and verification will increase exponentially. As $n$ is the length of the message digest, increasing it leads to higher security because it increases the collision resistance of the hash function. % weil mehr Winternitz-Ketten generiert werden, je kleiner w ist, reduziert ein hohes w die Signaturgröße
% The Winternitz parameter w enables space/time trade-offs.

% beide Gleichungen aus Buchmann-Grundlagenbuch

% bezieht sich auf #stücke in die m geteilt wird
\begin{equation}
\label{eq:t1}
t_1 = \ceil[\Bigg]{\frac{n}{w}}
\end{equation}

% bezieht sich auf #stücke in die checksum geteilt wird
\begin{equation}
\label{eq:t2}
t_2 = \ceil*{\frac{\floor*{\log_2 t_1} + 1 + w}{w} }
\end{equation}

% anzahl stücke von signatur M || C am ende
\begin{equation}
\label{eq:t}
t = t_1 + t_2
\end{equation}
The private key $X$ consists of $t$ bit strings, each of length $n$ chosen at random.

\begin{equation}
\label{eq:wots_privkey}
X = (x_0, \cdots, x_{t-1})
\end{equation}
The public key $Y$ is generated by applying the one-way function~$f$ to each element $x_i  \in X$  consecutively $2^w - 1$ times. % hier sieht man dass höheres w -> höherer Aufwand Keygen

\begin{equation}
y_i \in Y =  f^{2^w-1}(x_i), 0 \leq i \leq t-1 
\end{equation}

\begin{equation}
Y = (y_0, \cdots, y_{t-1})
\end{equation}
Each $y_i \in Y$ is a bit string of length $n$. The public key $Y$ has to be published before the signature can be generated.

\subsubsection{W-OTS Signature Generation}
For signing a message $M \in \lbrace 0,1 \rbrace^*$, the cryptographic hash function~h (see equation~\ref{eq:basic_hashfunc}) is applied to $M$ (see equation~\ref{eq:hash_message}). The resulting hash digest $m$ is split into $t_1$ bitstrings of length $w$. If $m$ is not divisible by $w$, it is necessary to add leading zeros to $m$ before splitting.

\begin{equation}
m = m_0 | m_1 | \cdots | m_{t_1-1}
\end{equation}
Each bitstring $m_i \in m$ is converted to its decimal representation in order to calculate the checksum $c$.
% checksum t2 Teile der Länge w teilbar

\begin{equation}
\label{eq:checksum_calculation}
c = \sum_{i = 0}^{t-1}(2^w-m_i)
\end{equation}
The checksum $c$ is divided into $t_2$ bitstrings of length $w$. In order to divide $c$ this way, it can be necessary to add leading zeros to $c$ as a padding.
\begin{equation}
c = c_0 | c_1 | \cdots | c_{t_2 - 1}
\end{equation}
Afterwards, $m$ and $c$ are concatenated to one block $B$. This leads to $t$ bitstrings of length $w$ in total, as $t = t_1 + t_2$.

\begin{align}
B &= m | c  \\ 
&= m_0 | \cdots | m_{t_1 - 1} | c_0 | \cdots | c_{t_2 - 1} \nonumber \\
&= b_0 | \cdots | b_{t-1} \nonumber
\end{align}
The signature $\sigma$ is calculated by applying the one-way function $f$ to each part of the private key $X$ (see equation~\ref{eq:wots_privkey}) several times: The element $b_i \in B$ determines the amount times the hash function $f$ is applied to the corresponding $x_i \in X$.

\begin{equation}
\sigma = f^{b_0}(x_0), f^{b_1}(x_1), \cdots, f^{b_{t-1}}(x_{t-1}) 
\end{equation}
% -> this looks weird, m | w vlt substituieren damit man nicht c_t2-1 als Exponent schreiben muss

\subsubsection{W-OTS Verification}



% keygen+sign+verify time / aufwand / speicherverbrauch -> Positiv: Wenig Speicherverbrauch, kleinere Signatur als bei Lamport-Diffie!

\section{Merkle-Trees}
